<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ちょうどよさのはなし on Message Passing</title>
    <link>https://messagepassing.github.io/008-justright/</link>
    <description>Recent content in ちょうどよさのはなし on Message Passing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://messagepassing.github.io/008-justright/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ちゃんとやりすぎた Chainer</title>
      <link>https://messagepassing.github.io/008-justright/05-shinh/</link>
      <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/008-justright/05-shinh/</guid>
      <description>Worse is better といえば、 Chainer ってちゃんとやりすぎていたのでは、て話をよくするんですよね。まあうまくさぼってたら競争に勝ち残れてたかというと別の話なんですけど。 Chainer の開発終了する時の PyTorch への移行ドキュメントとか、 PyTorch の人が感心してたりしたけど、ホント丁寧だなあと感心する。
一方で、 TensorFlow はともかく、 PyTorch はかなりわちゃわちゃしてて、こんなんでいいんだ……とよくなる。例えば、「LogSoftmax て exp に渡すの負にしないとすぐふっとぶから定義通りではダメで、なんかするけど、なにするんだっけ……」みたいなこと調べる時に、 PyTorch のリポジトリの下で git grep して、「さっぱりわからんな……」となってから Chainer 見てすぐわかる、みたいなことがよく起きる。ちなみに log(sum(exp(x))) を max(x) + log(sum(exp(x - max(x)))) で計算すると良いという話。
あのカオティックな状態で人気ナンバーワンというのは、さすが Done is better than perfect の総本山、と感心するものがある。なんかでもかくいう Chainer も高速な CPU 実行は numpy に丸投げ、 cupy の実装は大変とはいえ少なくともインターフェイスは numpy のものを使えば良い、など、割といい感じに手を抜けるちょうどよさを持っていたという側面もあるかもなあ、と。ちゃんとやらなさすぎても見捨てられるので、いい感じのバランスを取るのはかなり難しい、という話かもしれない。
 morrita 一方 TensorFlow は Move fast and break things しすぎて人々に見放されてしまったのだった・・・。はさておき NumPy の API は「ちょうどいい」一族に数えて良い気がする。   shinh TensorFlow に限らずグーグルは、ちゃんとやりすぎててもなんとかなるどころか人が余りまくって仕事を奪いあうくらいのリソースがあるから回ってる感がありますよね。まあ流行るかというと、あのいつもの社内のもの出しただけグーグル OSS 感ではなあ……というような話は別トピックですると良いですかね。</description>
    </item>
    
    <item>
      <title>Go言語のちょうどよさ</title>
      <link>https://messagepassing.github.io/008-justright/04-jmuk/</link>
      <pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/008-justright/04-jmuk/</guid>
      <description>Go言語は、なんというか「ちょうどいい」言語だな、と思っている。異論は認める。
Go言語の登場時、なんせGoogleが大々的に発表した新しいプログラミング言語であるし、Rob PikeやKen Thompsonといった有名人の関わりもあり、華々しかった。そして、その登場を眺めたプログラミング言語マニアは、そのダサい仕様にわりとすぐがっかりして、興味をなくした。ということがあったと思う。今はGoはけっこう広く使われていて人気もあるけど、ここに至るまでには紆余曲折があった。
Go言語、なにせ2010年代にもなってなんせジェネリクスもない（そのわりにスライスや配列、ハッシュテーブルだけが標準にあり、特別扱いされている）。例外処理もない（これはまぁそのほうがいいだろうという人もいるだろうけど）。そこらじゅう if err != nil だらけ。テストにアサーションもなく、ひたすら地道にif文を書くべしとされている。いくつかのビルトインな関数（たとえば makeなど）は構文上も特別扱いされていて、直交性がかけらもない。
オブジェクト指向的なことはできるが、C++やJavaのようなクラス志向ではない。継承が言語仕様にない。interfaceによるduck typingはできる。メタプログラミング的なことはやりづらい。オブジェクトは動的なところが一切ない。なんかデザインしづらそうだな、というふうに思った。
というわけで、登場時は「なんだかぱっとしない」「かっこよさがない」といったイメージであったように思う。すくなくとも自分は。
Go言語の「ちょうどよさ」 結果的にはこういうマニア視点はまったくのお門違いだったといえるだろう。Go言語はおおいに流行っている。これをGoogleによるゴリ押しだという主張はきっとあるだろうけれど、それはたぶん違う……もちろん、会社の支援のもとで言語仕様の改善や標準ライブラリの拡充などの発展があって便利になっていったという側面はあるけど、それはまあ「ゴリ押し」とは言わないだろう。
Goの独特のニッチにうまくハマったのだと思う。それはたとえばWebサーバやRPCサーバ、ちょっとしたユーティリティツールやサービスにあたる。GCがあって、並列処理ができ、標準ライブラリだけでもけっこういろんなことができて（http2サーバでJSONを返したりとが簡単にかける）、単純だけど静的型付けで単純な間違いは防げる。Goのインタフェース志向なduck typingは使ってみるとわかりやすく簡単だったし、実装の継承があると便利な場面というのも別になかった。こういう用途には便利だった。
言語マニアが「ださい」と思ったところは、実用上はそんなに大きな問題になることが多くはなかった。多くのGoプログラマが証言するように、Goを書いていてジェネリクスが必要なのになくて困るという場面はほんとうに少ない。もちろんまったくゼロではないし、今後たぶんジェネリクス的な機能は入ることになるだろうから、それはそれでいいことなんだけど、でも、マニアの文句なんてそんなもんだという話でもある。標準組み込み型の特別扱いがわりとうまく機能してるとも言える。
Goコマンドの導入によりツールチェインはわかりやすく使いやすくなったし、ビルドも速く、シングルバイナリでデプロイや配布が単純というのもよかった。こういうところは言語マニアはあんまり評価対象としないと思うけれど（言語そのものというよりは処理系の話だし）、そこには大きな意味があったと思う。Goは性能がよいというイメージ（実際のところ、最速でないにしろスクリプト言語よりは十分速い）も普及に一役買ったことだろう。
Goはworse is betterか？ Goの「ちょうどよさ」というのはどういうものだろうか。先進的でかっこいい理論にもとづいた複雑な言語より、ダサいけど使いやすいのがいい、というのが端的な評価になるとおもう。これはworse is betterを思わせるところがある。ただ、読み直してみると、Goはworse is betterでいうところのNew Jerseyアプローチではないように思える。
Worse is betterの結論というのはこうだ。実装が簡単で使うのも苦じゃないようなものは、みんなが勝手に再実装しやすい。そういう再実装は完璧じゃないにしてもまあまあ使えて同じぐらい使いやすい。そうやってウィルスのように広がっていく。MITアプローチで作られるものは、ぜんぜん完成しないか、完成しても使い物にならないかで流行らない。
JSONはまさにworse is betterといえる。自作JSONパーサを作るのだってすごく大変じゃない（性能とかを気にしなければ）。コンパクトでミニマルである良さみたいなものがある。
でもGoはランタイムも大きくてけっこういろんなことをしてくれる言語だ。GCもある。goroutineはカーネルスレッドの複雑さを隠蔽してくれる。再実装はぜんぜん簡単じゃない（実際、Goの再実装なんてllvm-goとか数えるほどしかない）。GoはいろんなOS、アーキテクチャに移植されてるけど、これはどっちかというとエンジニアリングリソースの投入量によるところが大きそうだ。それにまた、Goは裏側で意外といろいろ複雑なことをしてくれることがある。Goは間口の広さと取っ付きの良さ、仕様のわかりやすさによって普及したが、そのわかりやすさ、単純さのためには実装の複雑さを引き受けている面がある。かといってMITアプローチともいいがたい。
これはたとえばTOMLのちょうどよさにも通じるところがあると思う。TOMLは書き手にはシンプルでいい言語なのだが、これまたnew jerseyスタイルではない。実際に再実装するのは意外と厄介。仕様は細かいところまでいろいろカバーされており、こういう場合はエラーになる、こういう場合はこうなる、といった仕様をすべて正しく実装するのはじゃっかん面倒くさい。そういうこまかい部分がありつつも、全体的には「なんとなく人間が書いてわかりやすいような挙動」が取られるようになっている。データ型も日付型とかがあったりしてミニマルな良さもない。
まあいまさらworse is betterでもないだろうという話でもないのかもしれない。あるいは、MITとNew Jerseyの相克は、「ちょうどよさ」の新しい相を生み出したのかもしれない。これが今の時代のちょうどいい表現なのかもね。言い過ぎな気もするけれど。
 karino2 Worse is betterはそのまま現在に語るにはどうなのか、とも思う反面、現在のコンテキストでうまい感じに翻訳して語れんもんかなぁ、という気もしている。 YAGNIとかworse is betterとかってきっちりした主張ほどわかりやすく無いのだけど、割と重要なものを含んでいる気がするのだよなぁ。
自分のGo言語評価を聞きなおしたら、 worse is betterとは言ってないが似たような事を言っている気がした。
ちょうど良さというか、だいたいこんなもんでいいんだよ感というか。
  kzys Manning から出ている Functional Programming in Scala の著者の一人でもある Paul Chiusano が、The problematic culture of &amp;ldquo;Worse is Better&amp;rdquo; というのを2014年に書いていて、</description>
    </item>
    
    <item>
      <title>ちょうどいいシリアライザ、FlatBuffers</title>
      <link>https://messagepassing.github.io/008-justright/03-karino2/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/008-justright/03-karino2/</guid>
      <description>ちょうどいいテクノロジ、というのは確かにあって、誰でもぱっとJSON、Markdownまでは思いつくと思うのだけど、その次が意外と難しい。 morritaさんはdataframeを挙げていて、これは確かに何かの基盤になっているとは思うのだけれど、なんとなく自分的にはjsonと並べるとしっくり来ない。
ちょうど良いでしばらく考えて思いついたものとしては、SQLiteがある。PostgreSQLやMySQLがすでにある所で登場したSQLiteは、 そのちょうど良さゆえに普及した気がする。だけれど、そこから特に語る所が無い。ふーむ。
と考えていて、そういえば最近「これはちょうど良い！」って思ったものがあった気がするな〜と考えていたら、 FlatBuffersがそれだったのを思い出した。
ちょうどいいシリアライザ、FlatBuffers FlatBuffersはProtocol Buffersのようなもの。 ようなものってことはどこが違うの？という話になるけれど、自分はProtocol Buffersそんな詳しくないので違いを説明するのは難しい。 ということでFlatBuffersの話だけをする。なお、FlatBuffersとは何か、みたいなことはそんなに語らないので公式ドキュメントでも見てください。
FlatBuffersは凄くシンプルで、大したことをしない。そこが良い。 IDLっぽいものからヘッダファイルが生成されて、FlatBuffersのヘッダと一緒にincludeすれば良い。 リンクしなくて良い。いろいろなIDEのプロジェクトファイルと付き合わなくてはいけない自分の環境では大変うれしい。 生成されるファイルも単純で（比較的）小さい。読めばだいたい理解出来る。
メモリ上にすでにデータがあれば、そこからunpackして二重に持ったりしたくない、 オフセット指定してアラインとかエンディアンとか気にせず読み書き出来るくらいのに毛がはえたくらいでいいんだよなぁ、 生成されるenumとかはそのままenum classとしてC++で使えてさぁ、 フォーマットもそんなにかっちりしすぎず、フィールド足すくらいならデフォルト値で読めるくらいで昔のもそのまま読めて、 適当に手作業で必要な所だけ読んだりしたい、 でも配列とかは使いたいし文字列はいい感じに読めてほしい、 でも変な不定長とか要らないので読み飛ばしは簡単に出来てほしい、 みたいな、「こんなもんでいいんだよ」という思いに、ちょうど答えてくれるくらいの複雑さ。
使い方もそれなりにシリアライズの都合に合わせて出来ないこともあるのだけれど、 変にドキュメントできっちり仕様とか説明せずに、都合が悪いような使い方をするとassertで落ちる。そこをデバッガで見ると長々とコメントで何故ダメなのかが書かれていたりする。 そうそう、こんなもんでいいんですよ。
すでにある物を小さくして作るカッコよさ PostgreSQLやMySQLがある所でSQLiteを作る、とか、Protocol Buffersのある所でFlatBuffersを作る、 というのは、難しいですよねぇ。 あとから小さい物で市民権を得るのは、「より労力を集めた」では無く、センスで勝負している感じがかっこいい。 どうやったらそれが出来るのか？はちょっと難しすぎる気がするので、代わりになぜFlatBuffersを使う気になるのか？を、半歩離れて見るくらいをしてみたい。
FlatBuffersが凄くいろいろな所で使う気になるポイントの一つに、手書きで書いてもだいたい同じ感じになるだろうな、という気がするというのが挙げられると思う。 手書きとの差分としてのゼロオーバーヘッド感というか（FlatBuffersは厳密にはゼロでは無いけれど）。 手書きで書いてもたぶんあんまり変わらないので、手書きの所は全部これでいいか、と思える。 だからちょっとしたものでも少し大きいものでも、なんでもかんでもFlatBuffersにしよう、となる。 最近自分はバイナリフォーマットは全部これでいいんじゃないか、と思って積極的に使っている。
ライブラリにはゼロコストで出来る範囲のことをする、という生き残りの道が一つあるよなぁ。 それでは、ある種の「良くあるがいつもでは無いユースケース」でサポート出来ない物が出てくるのだけれど、 それはライバルのライブラリに任せれば良い。ゼロコストの範囲にとどまる事で必ず一定の需要はあるし、ライバルと差別化出来る。 ゼロコストの範囲で出来る事は限られているのでどんどん機能が複雑になる事も無い。
といっても、こういうのは実際に作って市民権を得る所まで行かないと、作るという選択の正しさを証明は出来ない気がする。 すでにあるのを使わずにダメに再発明しているのとの区別は結果でしか出来ないよなぁ。
 morrita FlatBuffers は Protobuf に比べて小さいだけでなく速いという明確な利点があるのが強いですね。 それがつまりゼロコストということなのだろうけれど。 Apache Arrows が採用しているのを見た時はちょっとびっくりした。
ただ X より速い X の代替品 Y は沢山あるけれど必ずしも流行るわけではないから、そこには crack すべき code があるのだろうなあ。
  </description>
    </item>
    
    <item>
      <title>ちょうどいいインターネット、Gemini</title>
      <link>https://messagepassing.github.io/008-justright/02-kzys/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/008-justright/02-kzys/</guid>
      <description>個人的には TOML は「ちょうどいい」かなあ。YAML の大変さがなくて、Dhall ほど野心的ではない。言われてみると、TOML の作者も GitHub の共同創業者の一人なので、だいぶ有名人ですね。
ちょうどいいインターネット、Gemini 私がここ一年くらい気になっているプロジェクトに Gemini がある。Gemini は Gopher と Web (HTML + HTTP) のいいとこどりを目指すプロジェクトで、行志向のワイヤープロトコルと、その上にのる、これまた行志向の text/gemini フォーマットで構成されている。
ここでいう Gopher は、Go のマスコットではなくて、1993年発行の RFC 1436 で定義されている、Gopher プロトコルのこと。世の中は広いもので、2021年の今現在も Gopher を使っていたり、それでブログのようなことをしている (ブログは Web + Log の略称なので、Gopher 上のブログは Gopher + Log を略して Phlog と呼ばれる) コミュニティが存在している。その中の一人 solderpunk が、Gopher の欠点を克服しつつも、Web よりもずっとシンプルなプロトコルとして設計したのが Gemini だ。
Web の複雑さがなぜ問題なのか? Project Gemini FAQ では、こう説明されている。
 Modern web browsers are so complicated that they can only be developed by very large and expensive projects.</description>
    </item>
    
    <item>
      <title>ちょうどよさのはなし</title>
      <link>https://messagepassing.github.io/008-justright/01-morrita/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/008-justright/01-morrita/</guid>
      <description>その「ちょうどよさ」ゆえに普及したテクノロジ - アイデアや標準があると思う。 そういうのは、科学や工学でなく匠としてのプログラミングを表している気がして成功が嬉しい。
自分にとって「ちょうどいいテクノロジ」の代表は JSON (2002) と Markdown (2004). どちらも技術的にはさほど大したことはないけれど、どちらも広く使われている。
「ちょうどいいテクノロジ」はこれ以前にも色々あった。UNIX(1969) や HTTP/REST (1991) なんかが思い当たる。 ただ同時代性がないせいか成功が華やかすぎるせいか、まいち親近感がない。 ついでにいうと、自分はもはやこれらに「ちょうどよさ」を感じない。 UNIX の代表 Linux は超巨大ソフトウェアだし、HTTP の最新版 HTTP/3 は随分複雑なプロトコルに見える。 JSON と Markdown は、今のところ当初の「ちょうどよさ」を留めている、気がする。 UNIX と Markdown を並べると怒られちゃいそうだけど、別に UNIX がだめって話じゃないんだよ。 自分にとって「ちょうどよさ」の範疇にないだけで。
「ちょうどよい」テクノロジの成功はよく Worse Is Better として説明される。 間違ってはいないだろうけれど、テクノロジの市場が scarcity から abundance にシフトする中でこの説明が十分な力を持っているとも思えない。 たとえば JSON 的なものは YAML なり TOML なりいくつかあった。Markdown にもライバルは沢山いた。 （自分は当時 Textile に肩入れしていた。RST は今でも現役だ。) これらはどれもまあまあちょうどよかったはずだけれど、JSON や Markdown の成功には及ばなかった。
何が違ったのだろう。たとえば Markdown の発明者が John Gruber や Aaron Swartz のようなインターネット有名人だった事実は、どのくらい成功を助けたのだろう。 あるいは JSON が JS のサブセットなのはどれくらい重要だったろう。 そういえば JSON の Douglas Crockford も有名人だ。</description>
    </item>
    
  </channel>
</rss>
