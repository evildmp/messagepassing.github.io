<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Message Passing</title>
    <link>https://messagepassing.github.io/</link>
    <description>Recent content on Message Passing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://messagepassing.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ハイテクないので昔話を</title>
      <link>https://messagepassing.github.io/006-hitech/04-kzys/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/006-hitech/04-kzys/</guid>
      <description>私もみなさんと同じで、自分でハイテクを書く機会というのはほとんどない。隣のチームの Firecracker はハイテク感があるけれど、QEMU の Tiny Code Generator の話 なんかに比べるとずっと平和で、別のアーキテクチャのエミュレーションをがんばったりはしない。
社内を見渡すと、EBS の Physalia なんかは、自分のチームとの距離の遠さも手伝って、だいぶハイテク感がある。これは morrita さんの書いていた「巨大製品の中で使われる、ドメインに特化したものを作る、組織戦のハイテク」だと思う。
2000年のハイテクと、2020年のハイテク 「Berkeley DB のようなものを再実装」と言われて思い出すのは Tokyo Cabinet のことで、そう考えると2000年初頭にミクシィで働いていたころには、C/C++ なミドルウェアが突如としてプロダクションに導入されることが時折あった。
ミクシィの全文検索は Hyper Estraier そのままではなかった気がするけど、KVS の Tokyo Tyrant はそのまま使っていたし、非同期実行の仕組みは、MySQL を分散キューにする Q4M がベースになっていた。GREE には KVS の Flare が、DeNA には MySQL の SQL 部分を迂回して NoSQL 風に使う HandlerSocket があった。
2020年代にこういうソフトウェアを作る機会はなかなかない。これには、オープンソースの既存実装の充実にあわせて、クラウドの発展もあると思う。自分で MySQL を運用していた人が、改造された MySQL を運用するときのギャップに比べると、Aurora みたいなマネージドなデータベースを使っていた人が、改造された MySQL を運用するときのギャップは大きくて、だいぶ頑張らないと説得しきれない。
アプリケーションを作る人々がビジネスロジックに集中できるのは良いことだし、私は AWS 勤務なので滅多なことは書けないけれど、でもまあちょっとの寂しさは感じる。
新しいプログラミング言語と再実装 そういえば、containerd では Berkeley DB の代わりに bbolt というのを使っている。
新しいプログラミング言語とそのコミュニティでは、C/C++ を呼び出さない &amp;ldquo;pure XXX&amp;rdquo; な実装が欲しいという需要がある。Ruby や Python だと、そういう実装は「遅いけれど、インストールが簡単」くらいのところに落ち着きがちだけど、Go なら十分に速い実装を書けるかもしれないし、Rust なら C/C++ から呼び出されるのも夢じゃない。Rust のパーサコンビネーターである nom の作者の論文、Writing parsers like it is 2017 (PDF) でも、VLC の FLV パーサーを Rust で置き換えたりしていたし、curl には Rust バックエンドが入るらしい。</description>
    </item>
    
    <item>
      <title>案外やってないなという感じ</title>
      <link>https://messagepassing.github.io/006-hitech/03-shinh/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/006-hitech/03-shinh/</guid>
      <description>ハイテク @Google ハイテク、グーグルにいた時の感覚は morrita さんに近い。「面接の時はアルゴリズム問題とか聞くけど、実際仕事で難しいアルゴリズムとか書いてないよね、簡単な再帰すら書かねーよな」みたいな雑談をよくしていた。11年くらい勤めて、あれはハイテクだったなーと思う自分の作業は 2,3 くらいで、期間としては合計半年から一年くらいじゃないかな。
割と、それで良いのだと思っている。5割の力で、余力を残して働くのがプロじゃないかと。余力があるくらいでできたプロダクトの方が、完成度が高い。持てる技術ギリギリを使って書いたコードは、たぶんバグってるか、開発に時間を使いすぎているか、悪いとその両方。
いざとなれば難しいデータ構造を使いこなすことも、超絶技巧の高速化もできるかもしれないけど、別に困ってないのに導入されたハイテクは単にメンテ性を落とすだけ。普通のコードで要件を満たせるのであればそれでいい。いざとなった時にハイテクができる牙を研ぐのは家でやればいい。その牙を使う日が来るのかは知らないけど。
ハイテク @PFN PFN に転職して、 PFN は零細企業や小規模スタートアップというほど小さい会社ではないけどなんだかやたらと多角的に色々やってるので、一人当たりの守備範囲は零細と大差ないんじゃないだろうか。入社して言われたことを要約すると「TensorFlow XLA の汎用性増やしたみたいなの作ってね、人員は一名。あ、インターンが一人いるよ」みたいな感じ。さあ大変だ、というか、できるわけないだろ！
できるかはともかくとして、これは楽しい。でも「ハイテクを一人占めするベテランはもういない、ハイテク祭りだ！」となってるかというと、あまりなっていない。自明にやるべきこと、ハリボテでいいから存在しないと話にならないコンポーネントが多すぎて、何を作っても「とりあえずここはこれで動くには動く……あとでもっとかっこよくしたいけど、もっとやるべきことがあるので、次に行こう」となる。それはそれで楽しくはある。
ベースライン 最近では「落ちついたらここは僕のハイテクですごくするんだ！楽しみだなあ。論文とかも参考にしちゃうぞ」と思っていたところを人に譲るというのが何度も起きている。いくつか例があったんだけど、 karino さんが最初に計算グラフの話をしていたので、それ系の話をしてみる。
計算グラフのスケジューラは topological order を満たしていれば計算順序を自由に変えていいのでなるべく速くなるように並べましょう、という問題。 DRAM が相対的に遅いので SRAM にあるデータをなるべく使いまわせる計算順が良くて、使い回せない時にどれを spill するかを賢く選びたい。最終的にはメタヒューリスティクスでも導入しましょ、という話をしてたんだけど(これはかなりハイテクぽくない？)高速に動作する貪欲のベースラインは欲しいので、とりあえず適当なのをでっちあげた。
計算順序はテキトーなヒューリスティクスで決めて、 SRAM が足りなくなったら spill する感じ。 DRAM と SRAM とか言うとソフトウェアエンジニアは構えてしまうけど、キャッシュから何捨てる？みたいな話なので、まあ LRU でしょとテキトーに最近使ってないのを捨てるつもりのコードを書いた。そのあとハイテクメタヒューリスティクスやるぞ、てことまで手が回らないうちに他のことやった方が良い雰囲気になってたので、アルゴリズム強いってウワサの人に譲ることにした。（強いってどんくらいなんだろ、と後から競プロサイトで検索してみたら、なんかちょっとドン引きするくらい強かった。）
その競プロすごい人は、なんだかすごい速度で僕の実装を改良再実装して、そこからさらに進めて当初予定していたメタヒューリスティクスまで実装してくれて、実際に高速化を達成、さらなる改良に従事している。ついでに「LRU は未来がわからない時に有効なオンラインアルゴリズムであって、将来の計算が静的にわかってる状況では単に最も遠い未来で使うやつ捨てれば良いことが知られてますよ」と指摘してくれたし、さらに言うと僕が LRU だと思っていたものはそもそも LRU になってなかった。
「後で自分でやろうと思って、それを楽しみにそこまでの道の整備をしたのにな」という気持ちも少しある。でも他の人にやってもらってみると、スケジューラの例のように、正直自分でやってたらここまで良くならなかったなと思うことがほとんどだし、労せず成果物ができているのだからまあいっか、となっている。
大企業を出て、今一緒に作業してる中ではたぶん僕が一番ベテランだし、ハイテクをやる権利も機会もあるのだけど、案外やってないなという感じ。立場とか環境とか機会とかもあるんでしょうけど、人に依存するする面も多いんでないかな、と。
 morrirta ここでいうベースラインは自分からみるとだいぶハイテクなので、 ハイテクの期待値は個人差がありそうですね。 プログラマにとってハイテクなコードとは「背伸びしたコード」なのかもしれない。
それはさておき難しいコードを競プロ勢に任せるの、すごいわかる。 ただ東京にいた頃は競プロ勢いっぱいいた気がするけれど転勤したあとすっかり見なくなりました。 気づいてないだけでみなやってるのかもしれませんが。
  shinh 日本、 OSS とかに参加するには英語のバリアが厳しいので競プロが流行る、みたいな仮説を持っています。もちろん公平な評価と明確な得点を好むとか、他の要因も色々考えられますが……</description>
    </item>
    
    <item>
      <title>ブックマークしたい</title>
      <link>https://messagepassing.github.io/005-bookmark/04-kzys/</link>
      <pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/005-bookmark/04-kzys/</guid>
      <description>みなさんありがとうございます。
自分も jmuk さんと同じ「虚無」に落ち着いてしまったのですが、昔はもうちょっとちゃんとしてたんですよね。どこからこうなったんだっけ。
虚無への道 最初に、ブラウザのブックマークの後に使っていたのは、今は亡き del.icio.us だった。その後に、はてなブックマーク に移ったのは、なんでだったっけ?
でも、しばらく使って思ったのが
 Go についてブックマークしたページに &amp;ldquo;go&amp;rdquo; とタグをつけるのは間違っていて、全文検索で解決するべき 言いたいことがあったらブログに書くなりメールを送るべきで、ブックマークでワイワイするべきではない  で、タグをつけるというアイデアと、ソーシャルなブックマークというアイデア両方になんとなくしっくりこなくなってしまって、現在に至る。
karino2 さんと morrita さんと同じように、仕事だと雑多なノート兼 TODO リストみたいなものを Quip に作っていて、そこにブックマークも行きがち。
仕事の外でもそうしたらいいかなと思って Evernote にノートを作ったりしているけど、いまひとつ定着しない。これは morrita さんの
 昔は Evernote とか org-mode のいわゆる journal に記録をつけていた時期もあったけれど、定着しなかった。Fragments は「友達に送る」という口実が少しは支えになってる気がする。
 これと同じ問題そう。一方で、結婚して子供ができてから、公開したくない/する必要がない情報がだんだん増えてきているので、公開することで何かを担保するのもなあ。Sharenting したくない。
とりあえず今年は Evernote か Scrapbox でやってみます。</description>
    </item>
    
    <item>
      <title>読んだ本はBlog、Webの記事は適当</title>
      <link>https://messagepassing.github.io/005-bookmark/03-karino2/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/005-bookmark/03-karino2/</guid>
      <description>向井さんのお察しの通り、全公開上等でブログですね。 ブログせずに読んだ本も少しはあるけれど。
このトピックの元だった2020年に読んだ本の話を書いた時は、過去のブログを眺めて、 あとはKindleアプリで他に買ったの無いかなぁ、と軽く確認したぐらいですね。 そういう点ではmorritaさんと似ている。
技術記事の場合、仕事で調査している時は社内のWikiを基本に、 Wikiに書くほどの事でも無い場合はSlackの分報に書いています。 仕事で読む物は記録は必ず残している。
仕事では無く、すぐ読んで終わりのつもりの技術ブログなどは、あまりちゃんと管理してないですね。 だいたいスマホで見かけてBOOXで読む、というパターンが多いので、 スマホからBOOXへはGoogle Driveのテキストファイル(自作メモアプリを使っている)経由か、 Pocket経由で送っています。Pocketは一応あとで以前読んだのを探す事は出来るので、ブックマークも兼ねて使っている。 使い分けには特にルールは無いけど、たくさん送る時はPocket、ちょっとSNSとかで流れてきたのが気になった、くらいだと自作メモアプリですね。
すぐに読む気は無いけど記録として残しておきたいwebの記事には、Google Bookmarksを使ってます。 いつサービス終了するかドキドキしながら使ってますが…必要十分でいいサービスだと思うんだけどなぁ。
論文は必ずGoogle Driveの特定フォルダ下に置く事にして、ちゃんと読んだ物は基本的にはブログを書く、というルールで管理していますね。
たぶん皆もそうだと思うけれど、全体的に昔よりも雑になってますねぇ。 前はもうちょっとちゃんと管理していたのだけれど。
あと誰も興味無いだろうけれど、なろう小説は、なろう公式のブックマーク機能を使っています。最新話を追っかけているものはカテゴリ1、読み終わったものや読むのを止めたものはカテゴリ2、 そのうち読もうと思っているものや読んでいる途中でまだ最新話には追いついていない物はカテゴリ3にしている。
morrita Google Bookmarks! まだあったのか!! しかも Maps 上で Like した場所のサイトが勝手に追加されている&amp;hellip;
自分も仕事関係で読んだものは、バグトラッカーなり作業記録なりからリンクしてます。あるいはコードのコメントとか、関連ドキュメントとか。 必要性があって読むものは文脈があるから、その文脈に埋め込めばよいよね。
  </description>
    </item>
    
    <item>
      <title>ブックマークはしない</title>
      <link>https://messagepassing.github.io/005-bookmark/02-jmuk/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/005-bookmark/02-jmuk/</guid>
      <description>みんな記録とかどうしてるんだろうっていうのは私も疑問に思ってたところがある（笑）。管理、一切してないというのが一番近いな。管理したほうがいいんだけど……。
紙の本については、書棚の量が今のところたかが知れているので眺めるぐらいでだいたいわかるようになっている。内容についてはだいたい見れば思い出す……というか思い出せないぐらいの本は自分にとって重要ではないっていうことだと思う。
電子書籍は、Amazon Kindleについては提供されているライブラリで事足りる。それ以外のものは、Google Driveにつっこんだりしているけれど、未読管理であるとか、いつ読んだかとか、感想とかは、なんにもしてない。基本的に買ったはしから読み、それで読まなかったものは埋もれていってしまっている気がする。PDFも同様で基本的には散逸しまくっていると思う。ポッドキャストで扱うであろう論文についてはそれだと立ち行かないので、Dropbox paperで読みたいPDFのリストをまとめているけれど、それぐらい。
インターネットの記事のブックマークとかは一層の虚無であり、読み終わったらそれで終わりということが一番多い気がする。あとで読む記事とかは、ブラウザのタブを開きっぱなしにしておいて後日見る、みたいな運用にしている。
という次第で、端的に要約すると、無。読んだものの管理はしていません。自分の記憶力と印象に頼りきりでボーッと生きている。さすがに何らかのものは記録したほうがいい気がしないでもない、と思いつつ、でも面倒だしな、というのを繰り返している。タスク管理もいろいろ試してみたがあんまりうまくいってないし。
基本的なソリューションはブログに書いておくことなんじゃないかと思うけれど、ブログはやっぱりなんか気合が必要になってしまった感がある。そんなにちゃんとした感想を書きたいわけでもないときもある。あと別に公開したくないときもある。というわけでうだう悩んでいる。
twitterはヘビーに使っているけれど、こういう用途には使っていないし向いていない気がするな。twitterをどう使ったとしても記録は簡単に散逸してしまう気がするので。
という本当に虚無みたいな回答になっちゃうんだよな。有野さんは全公開上等でブログっていうスタイルですか？</description>
    </item>
    
    <item>
      <title>Re: Re: Re: 今年読んだもの</title>
      <link>https://messagepassing.github.io/004-whatiread/04-kzys/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/004-whatiread/04-kzys/</guid>
      <description>ここ数年ずっと技術書は O&amp;rsquo;Reilly Online Learning (もう Safari と呼ばないんですね) で読んでいる。ACM の年会費を払うだけで、ちょっとだけ興味があるトピックに関してでも、本を複数冊パラパラと読めるし、O&amp;rsquo;Reilly の本だけではないので、本屋気分で新着を冷やかすのも楽しい。
ただ、高い技術書を買って値段分の価値をとるべく読み切る、という動機が弱くなるという問題があって、ここまでが長い言い訳なんですが、2020年は通読して印象に残っている技術書がありません。2021年はがんばります。
BPF Performance Tools jmuk さんと同じく &amp;ldquo;BPF Performance Tools&amp;rdquo; は途中まで読んだ。構成にはあまり不満はなくて「BPF すごいなあ。便利だなあ。なんでもできるなあ。」という印象。
BPF そのものは、bpftrace で色々書くのも DTrace みたいでかっこいいけれど、BCC に入っている小物スクリプトを使うだけでも結構良くて、昔だったらあたりをつけて strace したり、lsof を連打するような局面で「このホストの全ての open を tail -F 風にずっと流す」みたいなことができて便利。containerd/cgroup のこのバグを直したときにも使ったはず。
Practical TLA+ AWS 社員たるもの PlusCal 経由でいいので TLA+ くらい書けなくては、と思って読み出した。これはまだ本当に冒頭までしか読めていなくて、語るべきことなし。
著者の Hillel Wayne は TLA+ や Alloy など形式手法のコンサルティングやワークショップなどを仕事にしている人で、ブログもある。
Why the Sorbet typechecker is fast Sorbet は Stripe の開発している Ruby むけの静的型チェッカ。初期開発メンバーの一人である Nelson Elhage は、この他にも Sorbet の開発上の工夫について色々と書いていて、どれも面白い。
 Record/Replay testing in Sorbet Reflections on software performance  以前は Scala のコンパイラを書いていた Dmitry Petrashko も Sorbet には関わっていて、Software Engineering Daily ポッドキャストの Sorbet: Typed Ruby with Dmitry Petrashko で話している。</description>
    </item>
    
    <item>
      <title>ブックマークのはなし</title>
      <link>https://messagepassing.github.io/005-bookmark/01-morrita/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/005-bookmark/01-morrita/</guid>
      <description>From kzys:
 みなさんがするすると読んだものを列挙できるのにちょっとびっくりしているんですが、 ブックマークというか、PDF もふくんだ読んだものの管理ってどうしてます?
 そこそこのインターネット中毒者であるところのわたくしから・・・。 といっても家事子守とかがあると管理が必要なほど沢山のテキストを読めないので、今はそんなにがんばってない。
近況ニュースレター ここ二年くらい簡易 journal として Twitter の代わりに Notion や WordPress で箇条書き公開日記みたいな記録を つけてる。一週間で 1 ページ。 Fragments と読んでいる。
この Fragments の中に読んだものへのリンクと感想を並べ、ブックマークがわりにしてる。 これは世間の一部の人が Twitter にリンクを蓄積しているのと似たようなものだと思う。 公開する意義があるのか怪しい内容だが自分にとってはソーシャルメディアなので、 ページを更新するタイミングで友達数人に近況ニュースレターとして送りつけている。 （頼まれもしないのに送ってるのでニュースレターというよりは迷惑メールだけど。）
それとは別に古き良きブックマークサービスの Pinboard もつかっているけれど、 こっちは読んで「ない」ものと純粋に資料的価値のあるものをファイルしておくかんじ。 プライバシー優先のため Pinboard は公開していない。 日本の人だと「はてなブックマーク」とかを使うところだと思う。 Pinboard は特段優れた機能を持つわけではないが、 ソーシャルメディアではなく単なるツールなのでうっかり嫌な気持ちにならない点は良い。
Podcast のために読む論文の管理には Paperpile を使っているが、 自分は別にアカデミアではないので書誌管理機能は活用していない。 付属の PDF ビューアの出来の良さと、論文特化の Chrome extension とかが割と良い。 ただアカデミアみたいに大量に読んでしかも引用するとかで限り Pinboard のような普通のブックマークでダメな理由は無い気がする。
電子書籍類は大して量がないので電子書籍アプリの書棚で足りている。 あと先の Fragments やブログに感想文を書いたりもしている。
こうしてみると純粋に時系列に読んだ記録としては Fragments が一番機能しているかな。こないだの記事を書くのにも見返した。 昔は Evernote とか org-mode のいわゆる journal に記録をつけていた時期もあったけれど、定着しなかった。 Fragments は「友達に送る」という口実が少しは支えになってる気がする。 Twitter や Facebook でダメなのかは個人によると思うけれど、自分は気が散りすぎて無理。</description>
    </item>
    
    <item>
      <title>Re: Re: 今年読んだもの</title>
      <link>https://messagepassing.github.io/004-whatiread/03-jmuk/</link>
      <pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/004-whatiread/03-jmuk/</guid>
      <description>いろいろ忙しかったのと、私事などもあり、2020年はあんまりいろいろ読んだりはしない年になった。のであんまり書くことなかったりするんだよなぁ。
reMarkable2 話をふられたのでまずそこから書くと、reMarkable2を買った。e-inkのタブレットデバイス。なかみは独自のOSで、基本的には文書や本を読むためのものというくくり。見かけてすぐ予約したけど、パンデミックの影響もあり、入手したのは10月。まだそんなに使いこなしているわけでもない。
もともとの動機として、論文を読むのに向いてるe-inkタブレットがほしかったのだった。reMarkable2は基本的にはPDFとepubリーダになっていて、PDFとかebookはアプリ・拡張機能からクラウド経由でデバイスに送り込んで読める。その用途なら、Amazon Kindleデバイス＋instapaperでもまぁいいんだけどね……（まあそれなりの大きさがあるのは良い）。
e-inkリーダとしての性能は、まあそこそこかな。やっぱり画面遷移が遅いし、前後のページにしか遷移できないので、いきなり前の方にジャンプしたりできなくて、ちょっと不便。でもやっぱり読みやすい。それと、専用のスタイラスがあって、PDFでもebookでも好き勝手にメモを書き込めるのが面白い。というわけで、論文読みデバイスとしてはなかなか優秀だと思う。でもまあ、向いている人が必ずしも多いわけではないニッチ製品かなぁ。いちおうウェブページも同じ仕組みで（ebookに変換して転送して）読むことはできる。けどまあウェブ閲覧としてはイマイチ。やってみたら日本語ウェブページも読めなかったし（日本語PDFは読めるようだ。フォント埋め込みしてるからかな）。
Let&amp;rsquo;s Encrypt: An Automated Certificate Authority to Encrypt the Entire Web というわけで、reMarkable2で読むのはもっぱら論文なんだけど、読んだ論文は基本的にはポッドキャストで紹介するつもりなので、ここで紹介するものがあんまりない。ただそういえば、このLet&amp;rsquo;s Encryptの論文はおもしろかったけどポッドキャスト向きじゃあないかも。あんまりアカデミックな内容じゃないんだよね。
Let&amp;rsquo;s Encryptのことのおこり、組織構成、資金、クライアントツールのデモグラフィック、成功の要因などが詳しく書かれている。技術面だとLet&amp;rsquo;s Encryptのプロトコルが解説されていて、これでようやくどういうものか理解できたっていうのはある。完全に自動化されていて間に人間がいっさい介在しない（できない）っていうのはやっぱり面白いね。
そういえばLet&amp;rsquo;s Encryptの証明書は有効期限が短く3ヶ月しかない。それはまあちょっと不便なんだけど、なぜそうなっているのか。なんとなく勝手に、完全自動化で無料である意味でほかのCAのような信頼性の担保がないからだとずっと思っていたが、この論文を読んだらぜんぜんそういう理由じゃなかったので、そこは読んでて思わず声が出た。有効期限が短くなれば人間としても手作業で更新するのが手間になるから、ユーザ側も更新をcronなどで完全自動化するモチベーションが出てくる。そうなるようにわざと短い有効期限にしているのだそうだ。そうだったのかよ！？
BPF Performance Tools さて、本でいえばBPF Performance Toolsを2020年初に買っていた。BPFまわりで活発に活動しているBrendan Gregg氏の本だ。めちゃくちゃ分厚い。あと残念な告白をすると、通読はできていません。
買って読んでみてわかったのだが、ある意味では膨大なレシピブックという側面があり、こういうことをしたいならこうする、といったコードサンプル、事例がふんだんに盛り込まれていて、扱われているネタは広範なんだけど、悪くいえば散漫でもあり、なんか読みづらい。序盤の数章は読んで面白かったんだけどね。karinoさんも、Brendan Greggの他の本への感想に似たようなことを書いていたので、これはこの人の方向性ということなんだろう。悪い本ではぜんぜんないというか、持っていて良い本だとは思うけれど。
並列コンピュータ &amp;ndash; 非定量的アプローチ 出身大学の天野英晴先生が書いた日本語の本。これは面白く読んだ。並列コンピュータの構成方法についての細かい話がいろいろわかりやすくまとまっている。たとえばキャッシュコヒーレンシや共有メモリモデル、クラスタマシンなどなど。まえがきによれば過去あった本の再編とのことだけど、最後にGPUなどのアクセラレータを扱った章も書き足されている。こういう分野は普段の仕事と縁遠いから、それゆえに読んでいて面白い。
なお、タイトルはヘネパタ（『コンピュータ・アーキテクチャ　定量的アプローチ』）をもじったものだけど、そんなヘネパタみたいなことは普通はできないし、複雑化したコンピュータを定量的に理解するのもだんだん難しくなってきているから……といった話がまえがきに書いてあるのがわりと面白い。これは出版社のサイトの「試し読み」から一読できるので興味があればどうぞ。
Reverse Engineering the source code of the BioNTech/Pfizer SARS-CoV-2 Vaccine そういえば年末に読んだこれはけっこう面白かった。新型コロナウィルスのワクチンの「ソースコード」を解説する記事。DNAの各パートについて、それぞれがどういう意味なのかを説明してくれている。この記事にかぎらず解説記事というのはいくつもあるものだと思うけれど、この記事はプログラマによる解説記事なのでプログラマが読んでわかりやすいたとえが入っているのが特徴。これを読んだ後にほかの解説記事を読んだら理解しやすくなったように感じた（気のせいだと思うけど）。日本語翻訳も上がっていて、そちらも良いけれどこのプログラマ向けっぽい感じが少し薄れている気がする。
 morrita 自分も BPF Performance Tools 読みました。 Systems Performance もそうですが、 この人の「持っている知識の確かさ」と「著者としてのいまいちさ」のギャップはなんなんでしょうね・・・。   </description>
    </item>
    
    <item>
      <title>Re: ハイテクしごと</title>
      <link>https://messagepassing.github.io/006-hitech/02-morrita/</link>
      <pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/006-hitech/02-morrita/</guid>
      <description>大企業におけるハイテク私感 大企業下っ端なので全然ハイテクとかしてない。 ここでいうハイテクは、それなりに (CS 的な) 難しさのある、それなりの規模のコードという風に解釈している。
ある程度成熟した大企業だと、インフラ部門とかリサーチ部門とかがあってハイテクなものを専業で作っている。 なのでハイテク指向な人はそういう部門ではたらく傾向がある。
一方のアプリやサービス部門の人は、実製品開発が好きだからそういうチームにいる。 だから個人の性向としてハイテクより仕事を片付けるのを優先しがち。 それを退屈に感じたこともあったけれど、最近は締切を守ってモノを出す姿勢も大事だなと考えるようになった。 なぜならちゃんとモノが出ていくから。大企業、野心的すぎて完成する前にお蔵入りしてしまうプロジェクトもよくあるね。
専業のインフラ部門とは別に、巨大製品チームはインフラ部門やリサーチ部門相当を内部で抱えている。 たとえば YouTube は Procella というデータベースを内製しているらしい。わけがわからない。 製品内ハイテクはインフラやリサーチ発のテクノロジよりドメイン依存で、身近な面もある。 とはいえ巨大製品のハイテクは黎明期の発明の二周目三周目なことが多く、個人作品というより組織戦の色が濃い。
そんなアプリ・サービス部門でもバーンと一周目のハイテクをキメる人はたまにいて、 そういう野心がある人はだいたい出世して TL とかになる。そして二周目三周目の製品内ハイテクプロジェクトを主導していく。
つまり実勢品でハイテクをキメられるくらいならもっと出世してるっつーの！（突然の八つ当たり。） 下っ端の実力は推して知るべし。
傍から見ていると、小さいチームより成功してある程度規模のあるチームの方がハイテクの機会は多いように見える。 というのも小さいチームは技術的障壁以前に product-market fit みたいので苦戦することが多いので、 よくいえばスタートアップ的に動くものを優先しがちだから。成功して、はじめてハイテクの必要性が生まれるのではないか。 あと勢い良く伸びている製品の方が予算の融通が効く面もある気がする。やんちゃする余裕がある。
テクノロジーありきの製品も色々あるけど、 というか自分が仕事で手伝っているのもそうした製品の一つだけれど、コアテクノロジは先に書いたようなリサーチ部門や、 リサーチ部門ではないにせよリサーチ的な性格のチームとから出てくることが多い。 たとえば実験的な OS を作ってしまうチームとか。
零細企業でのハイテク 自分が零細企業勤務だった十年前のことを考えると、その会社はなぜか自社ミドルウェア用に公開鍵暗号を実装していた。 細かいことは忘れたが他にも似たレベルの再発明ハイテクがもう一つ二つあったと思う。 再発明に見合う品質やユニークさはなかったと思うが、組織の未熟さゆえにこれらのハイテクは生まれることができた。 要するに良くない判断を止める人がいなかったからやんちゃできた。こういうのは零細、中小企業だと割とよくある話だと思う。
製品の要請から意味のあるハイテクが生まれることは、小さい企業でもあるだろう。 インフラ部門やリサーチ部門がないぶん製品チームが腕まくりしてハイテクに挑む。 karino2 はきっとこのケースに近いのでしょう。
企業規模とは無関係に、ハイテク自作の文脈でオープンソースの影響は無視できないと思う。 よいニッチを見つけないとオープンソースの既存実装に勝てない。 自分で何か書くと言い張るのは、昔よりやや難しい。 オープンソースの隆盛にあわせ、世の中全体としてハイテクを自作する割合は減っているんじゃないかな。 ソフトウェア産業は拡大してるから絶対数は増えてるかもしれないけれど。
ベテランの気晴らしハイテク 権力のある古株のエンジニアが、仕事に飽きて気晴らしにハイテクをはじめてしまうことがある。 そんなハイテクは難しくて新しいことをすること自体が動機になりがちで、製品の要請に基づかないことが多い。 その一方で権力者の仕事だけに割と影響範囲もでかくなりがち。
森田は過去に何度もこの気晴らしハイテクを目撃しており、そのせいで迷惑したことも一度ではない。 そのせいかこうしたプロジェクトには強い嫌悪があり、 反動でなるべく地味に堅実な成果を出したいバイアスがある。
とはいえ退屈していたベテランが考え事をしていたら製品の隠れた要請に気づいてしまうこともあるわけで、 あるハイテクプロジェクトが製品の要請なのか単なる気晴らしなのかは、最初ははっきりしない。 自分が「それ趣味プロジェクトでしょ」と斜に構えていたらいい成果を出したベテラン発のハイテクも何度か目にしてきた。
小粒な気晴らし 自分も今のチームに異動して三年。社歴に至っては十年。だいぶ飽きている。 あーなんか気の利いたコードを書きたいなーと思いつつ地味にバグをなおして暮らしている。
が、ふとした思いつきから年末に仕事でプログラミング言語を実装した。 三日で書いて二千行みたいな超小粒言語で、仕様も大学生の宿題みたいに素朴なもの。 GC も Java まかせで、ハイテクとは程遠い。 ただ「仕事でプログラミング言語を書く」というハッタリじみた響きが気に入っている。</description>
    </item>
    
    <item>
      <title>ハイテクしごと</title>
      <link>https://messagepassing.github.io/006-hitech/01-karino2/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/006-hitech/01-karino2/</guid>
      <description>お仕事で計算グラフなコードを書いた 先日、仕事で計算グラフを構築して変形して実行するようなコードを書く必要があって、 そんな類のライブラリを書いて機能を実装した。コアの部分で1万行くらい。まぁまぁ大変で三ヶ月くらい掛かった。
DSLで計算グラフを構築し、 それをいろいろと操作し、最後に生成されたIRをなんらかの形で実行する。 ここ数年、こうした形で新しいものがいろいろ生まれているように思う。 古くはLINQ、より最近だとTensorFlowとかHalideとか。 あまり詳しくないが分散ビルドなどもこうした形式だとか。
そういう訳で近年この手の、実際にコードと実行の間に一旦シンボリックなグラフを置いて、 それをいろいろ操作する事で、そのまま実行するのでは得られない付加機能をつけるのは一般的になっている気はしていた。
でもそれを自分で実装するのは今回初めてで、おぉ、これが噂のあれかという気分。
ハイテクな物を実装するレア度とチャンス こういう流行りのハイテク技術を仕事で実装する機会というのはどの位レアなものだろうか？ バグを修正したり普通の機能を足すような「日常のタスク」よりはだいぶレアな気がする。 でも、ハイテクなプロダクトを売りにしていこうと思えば一つや二つは含まれる事もままある訳で、 それを実現するのが我らであることを思えばそこまでレアでも無いのでは無いか。 仕事をしていれば2〜3年に一回くらいは実装して良いような機会に出会う程度のレアさな気もする。（本当だろうか？）
一方で実装しても良い機会にあっても、別に実装せず見過ごす事も出来る。 仕事のタスクとして現れるハイテクな可能性には、だいたい迂回してもっと普通に泥臭く実装できる方法がある。 LevelDBを新しく作らずにSQLiteを使う事も出来る。 TensorFlowを実装せずにOpenMPとCUDAで手書き実装していく事だって出来る。 機会がある事と、その機会に直面した時にハイテクの実装に踏み切る事はイコールでは無い、というか見送る事も多い気はする。 踏み切るかかどうかは立場や環境にも依る。
チームの規模とか会社の規模とか 大規模チームだと、本当に一握りの中心に居るエースしかそういうのにチャレンジしない気がする。 別に末端のプログラマもガンガンチャレンジしていっても良い気もするが、あんまり見かけない。
大規模チームでは一部の人だけかもしれないが、大企業という枠ならどうだろう？ 大企業でも小さなプロジェクトの立ち上げなら割と自分でいろいろ実装する機会はあるので、 普通のプログラマでもそれなりにハイテク実装する機会もあるのかしら？「普通のプログラマ」の定義も難しい所だが。
小規模のスタートアップなら、テクノロジーを売りにするならそういうのには挑みそうな気もするが、、、挑むかな？ 口先だけではやってるとは言うだろうが、本当にやってるのがどのくらいいるかは良く分からない。 失敗するとそこで会社は終わりなので、結構勇気はいる。 今回自分が実装に踏み切る時も、頓挫したらごめんなさいねと説明した上で始めた。 気軽に失敗させてくれるのはCTOの器かもしれない。
何がハイテクなのか 完全に主観の話になりますが。
例えばコンビネータ型のライブラリを自分で作るくらいなら、目新しい応用例なら自分的には日常からはずれたハイテクの範囲に入る気がする。 でも、本質的にパーサーだが微妙にテキストじゃない、みたいな、既存のパーサーコンビネータそのまんまの用途の場合はハイテクという気もしない。 割と新しい用途にコンビネータ型の解決を見出す所にハイテク感を感じる訳だ。 余談だが、今回自分はコンビネータ型のライブラリでクールに作れる所を気づかずに手実装してしまい、後で気づいた。悔しい。 みんなはどのくらいコンビネータ型のライブラリを仕事で自作する機会ありますか？＞all
FollyのFutureを参考に自分らの環境でFuture-Promiseを実装するくらいではハイテクとは認めない。 C++だとそれなりにenable_ifとか必要だけれど。 通常のタスクの中の普通のライブラリ作成くらいだとハイテク感は感じないよなぁ。FutureをAtomicだけで実装するとかかなり大変だけどね。 大変さとハイテク感はまたちょっと違うんだろうな。かっこよさが無いとダメな気がする。 Futureにハイテク感を感じないのはいまさらに感じるからかもしれない。
なんとなくだが、自分の中ではBerkeleyDBのような物を再実装するのはハイテク枠に入っている。 再実装自体はどうという事も無いのだけど、わざわざそんな物を再実装するくらいの何かを作っているというのはハイテクな気がする。どうだろう？
仕事でハイテクな何か実装する機会とか、ハイテクとはそもそもどんなものかとか、その辺どうっすか？＞ハイテクに一家言ありそうなmorritaさん</description>
    </item>
    
    <item>
      <title>Re: 今年読んだもの</title>
      <link>https://messagepassing.github.io/004-whatiread/02-karino2/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/004-whatiread/02-karino2/</guid>
      <description>今年はあんまり読んでないかと思っていたが、見直してみると数は多いので代表的なのだけ。
System Performance Brendan Greggの本、これは仕事をはじめる前の無職の頃に買って読んでいた本。 森田さんが良くBrendan Greggの言及をするので自分もdtraceって奴をちゃんと勉強しておくか〜、と思って買った。能書きが多くて同じようなことを延々と繰り返してて辛い本だが、レシピ集的には素晴らしい、という二面性のある、評価の難しい本。当時の読書記録はこちら。 読書記録: System Performance
なお、パフォーマンスつながりでiOSの事情を知る為に iOS and macOS Performance Tuning: Cocoa, Cocoa Touch, Objective-C, and Swift も読んだ。 そんなに深い話では無いが、普通にiOS上で使えるツール等が書いてあってiOSの基本的な話題もあって悪くはない。 ちなみにiOSではdtraceを使えそうな事が書いてあったが、たぶん使えないのでは？でもiOSにトレーシング系のプロファイラが無いというのも信じがたい？知っている人居たら教えて下さい。
C++の本 今年はC++の本をいろいろ読んだ。
 The C++ Programming Language 4th edition Effective Modern C++  上記２冊の当時の感想 最近読んだC++の本2冊の感想   Modern C++ Programming Cookbook  この本はいまいち。当時の感想 書籍: Modern C++ Programming Cookbook    一番上のStroustrup本は業務でも日常的に（一日に数回くらい）参照するくらいには良く使ってる。 でもこの本がC++ 11までしか扱っていない、というのが、 現状のC++を学ぶ時の困った状況を表している気がする。せめてC++14に対応した版が欲しいなぁ… 上２冊は良い本だとは思うけれど、これだけでは言語をとりまく状況の複雑さを思うと、全然足りないなぁ、とも思ってしまう。 Stroustrup本は1279ページ（！）もあるのに足りないとか言われても…という気もするが。
* OS Internals iOSとOS Xのインターナルの本。何故か物理本でしか売ってない上に上記のサイトがどう買ったらいいか謎が多く、Paypalでお金を振り込んでメールをする、みたいな不安のあるフローで、HTTPSじゃないし怪しさ爆裂。でもちゃんと届いた。
期待よりもOS Xの話が多くてちょっとがっかりだが、InternalはOS Xの方がわかるんだろうねぇ。 やっぱコアの部分はAndroidの方が良く分かるので勉強し甲斐は向こうの方があるよなぁ。</description>
    </item>
    
    <item>
      <title>Re^3: テキストエディタのはなし</title>
      <link>https://messagepassing.github.io/003-editors/04-karino2/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/003-editors/04-karino2/</guid>
      <description>自分もjmukに似てて、VS Codeです。 以前のように自分でいじったエディタを使ったりはしてないですね。 あまり面白みは無いですが、それが何かの結論を表している気もする。
現在のエディタ環境 メインはVS Codeでエディタ作業はプログラム以外もこれでやっている。 Cloudとかターミナル上の作業ではvimも使っている。カスタマイズ無し。
また、Android開発はAndroid Studioで、iOSはXCodeで、Qt開発はQtCreatorを使っている。 これらのIDEを使っている時間もそれなりに長い。 自分はデフォルト教の熱心な信者なので、 全て基本はカスタマイズ無しのデフォルトで使っていて、 各環境に自分の方を訓練で適応させている。
RascalとIDE体験 自分は昔、xyzzy というエディタをいろいろいじったカスタム版を自分でビルドして使っていて、lispもかなり書いていた。 かなり重度のEmacs系エディタ派閥だった。
ところが2005年に Microsoft 社内向けの簡易版VSであるRascalというのを使うようになり、 これがめちゃくちゃ出来が良かった。 今振り返るとこの時がEmacs系エディタ派からIDE派に鞍替えした瞬間だったと思う。
Rascalは、外にリリースされた物ではVisual C# Express Editionに近い。 だがRascalはよりエディタ的に使えて、小さいのでインストールもすぐに終わって、 デバッガもついててリファクタリングブラウザも補完もちゃんと動いた。 テストサーバーでテストがこけた時なども、ログインしてちょろっと持ってきてデバッグに使えて良かった。 このRascalが自分的な最初の現代的なIDE体験で、 これ以降メインの環境はIDEにしようと思い、IDEの学習に多くの時間を投資するようになった。
この2005年が自分には画期だったと思う。 世の中もIntelliJが革命的な進歩を果たしたのは2004年という事になっていて、 この2004年〜2005年あたりにIDEの時代が到来したんじゃないか。
今回のトピックでもVS CodeとIntelliJ系列がほぼ全てを占めているので、 15年かけてJavaとC#以外の環境にもその２つが浸透したんじゃないか。 だが15年の間にはそれなりに回り道もあった。
それ以外のIDEとしてのVS Code Rascal以後、全てがIDEになってめでたしめでたしになるかと思っていたが、その後クラウドの時代が来ると、 スクリプトなどを書く事が増えたり設定をしてないターミナル上（EMR上のインスタンスの中とか）での作業が増えて、 vimとか原始的な環境で作業をしてた。
この辺の時代になると、自分の環境は、
 IDE上の開発 IDE以外での開発  の2つが大きく分かれた別の世界になっていた。 IDEは日々進んでいて新しい機能が入っていく。 一方でIDE以外での開発は昔から変わらぬ環境。
IDE以外の環境ももうちょっとなんとかならんかなぁ〜と思っていた所にVS Codeが登場した。 触ってみると昔のRascalっぽい。いいねっ！と一気にファンになり、 IDE以外の世界にもIDE的な物がやってきて、以後みんな幸せに暮らしましたとさ。
vimの台頭 自分は長らく Emacs 系エディタに多くの時間を投資していたが、 IDEの時代、そのあとクラウドの時代が来てみると、Emacs系のエディタは不便さが目立つようになる。 一方でvimは自分のマシンでない一時的な環境での作業やIDEの隙間のちょっとした作業にいい感じにミートして、 それ以外+vimという形で割と皆が使うようになってきた（気がする）。 自分もそうだしjmukもそうだと言っている。
vimの方がEmacsよりもむしろ現代的なのは、逆説的で面白いなぁ、と思うのだった。
morrita 案外あっさりおわってしまった。時代ですかね。
なお読者への補足として karino2 と jmuk は一時期 VS Code のコアを使ったウェブベースのエディタを開発していた VS Code 愛ある人々です。</description>
    </item>
    
    <item>
      <title>Re: Re: テキストエディタのはなし</title>
      <link>https://messagepassing.github.io/003-editors/03-morrita/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/003-editors/03-morrita/</guid>
      <description>自分の状況は 向井さんと似てる。つまり Emacs は使ってない。 ただ VS Code もそんなに使ってない。VS Code は他のものがないときの fallback というかんじ。カスタマイズもしてない。 仕事が Andoid アプリなのでそこは必然的に Android Studio. 一時期サーバ側の C++ を書いていた頃は CLion に金を払っていた。 これらは今はリモートデスクトップ越しに使っている。きびしい。
Git のコミットログとかは vim だけれど、それはエディタというより Git の機能みたいな気分で使ってる。まったく使いこなしてない。 2020 になってようやくコピーアンドペーストのキーバインドを覚えた。なにこれ革命的に便利。
仕事だと他に社内の Web-based のエディタがあって、最近は Java 以外だとだいたいそれを使っている。
Web-based なエディタ その内製 Web-based エディタ、所詮は内製ツールなので VS code みたいな出来のよさには遠く及ばない。補完もなんとなくされるかな程度。 イメージとしては Jupyter Notebook/Lab くらいの編集力。ただレポジトリとくっついてるのでブラウザ上でブランチつくってコミットもとかできるし、ビルドもテストもできる。 コードレビューも出せる、のみならず、レビューコメントがエディタから見えたりもする。
あとコードは CITC という仕組みで ブラウザ上での編集がなぜか手元にも反映されるので、ブラウザでできないこと (ビルドされたアプリを adb install するとか)はローカル環境でできる。
サーバ側のプログラマにはこれだけで暮らしている人も割といる。ほんまいかなと思うけど、 いわゆる「コード」だけでなく謎の設定ファイルをいじる仕事が大量にある場合はウェブエディタでも大差ないのかもしれない。 SQL や Python みたいにどのみち IDE の強力な支援が期待できない言語にも同じことがいる。 リモートデスクトップと比べるとキータイプ単位でレイテンシが無いのも良い。不毛な比較だけれど。
Web-based なエディタが存在できる理由の一つは「ローカルの設定」を必要としない monorepo と hermetic build の力かもしれない。 エディタからのビルドは要するに CI をトリガするようなものだけれど、ビルドのたびに環境をつくったら時間がかかって仕方がないし、 状態のキャッシュとかも下手にやるとビルドの安定性を損ねる。そのへんの問題が解決済なので Web-based エディタでもなんとかなる。</description>
    </item>
    
    <item>
      <title>今年読んだもの</title>
      <link>https://messagepassing.github.io/004-whatiread/01-morrita/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/004-whatiread/01-morrita/</guid>
      <description>年の瀬なので振り返りもかねて今年読んだものでも紹介してみたい。 (草稿を書いたのは年末だけど、ぼんやりしてるうちに年が明けてしまった！)
といっても森田は今年は他人に勧められるほど良い読み物との出会いはなかった。 世が不作なわけではなく、パンデミックのせいで可処分時間や心の余裕がなかった。 なので他の人のおすすめに従って失われた一年をちょっとでも取り戻したい下心がある。
それでもブックマークなどを発掘したら少しはものを読んでいた（あるいは audiobook で聴いていた）ので、 その範囲で面白かったものを紹介したい。
まず書籍 3 冊。
Remote: Office Not Required Rails の開発者 DHH がつくったウェブ企業 Basecamp (当時は 37signals) がリモートワークについて書いた本。2013 年出版だが、 パンデミックの今年読むと趣深い。いいこと言ってる。7 年の月日を経てテクノロジーの問題はだいたい解決した感があるけれど、 文化的には企業間の差は大きいように思う。この本は動きの鈍い大企業に先んじてリモート化を進め差をつけろと謳う。 自分は差をつけられる側だと思うと複雑な心境。
リモート勤務、企業の個体差だけでなく我々従業員の個人差も大きいと思う。 たとえば長い通勤と引き換えに広い家を選んだ人はリモートが嬉しいだろうし、 通勤を縮めるために狭い家、高い家賃を選んだ自分のような人に嬉しさは薄い。 パンデミックはさておくと自由度の高い独身者はリモートワークの柔軟性を目一杯活かせる一方、 自分のように妻子があったり、更に子が就学していたりすると、 学校という時間的・地理的自由ゼロの活動に縛られてリモートがもたらすはずの生活の柔軟性は生かせない。
Basecamp 書籍は読むたびに我が身とくらべしょんぼりするが、そのしょんぼりが顕著な一冊だった。リモート欲を高めたい人にはおすすめ。
Facebook: The Inside Story Steven Levy による Facebook 読み物。 In the Plex や The Everything Store が好きだった人にはおすすめだし、それだけでなくゼロ年代のウェブの盛り上がりを生きてきた自分と同世代のひと（おっさん）も楽しく読めると思う。 今は色々言われている Facebook だけど、「ウェブでクールなサービスを出してゲットリッチ」というその世代の夢の頂点なのもまた事実なので。
電話機の OS を開発していた（が途中でやめた）話など、それなりに目新しいインサイダーストーリーも多い。
Google BigQuery: The Definitive Guide: Data Warehousing, Analytics, and Machine Learning at Scale 自分は仕事でよく BigQuery (の祖先の Dremel) の SQL を書いているが、いかんせん SQL 素人すぎていつも辛い。ちょっと付け焼き刃でなんとかしたいと思っても、世の SQL 入門書は OLTP 系の用途に偏っていて分析/OLAP 向けの入門に良いやつがない。しかも BigQuery/Dremel の SQL はネストしたデータがバンバンでてくるなど特殊な面も多い。助けてくれ・・・とおもってこの本を眺めたら、そういう「SQL 素人が BigQuery でやっつけ仕事をする」のに必要な SQL がちょうどよく紹介されていて救われた。ユーザ分析とかしたいけど SQL わからん・・・と腰が重いモバイル開発者におすすめ。</description>
    </item>
    
    <item>
      <title>Re: テキストエディタのはなし</title>
      <link>https://messagepassing.github.io/003-editors/02-jmuk/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/003-editors/02-jmuk/</guid>
      <description>エディタ、いまはもうだいたいVScodeだけでやっている。昔はEmacsだったけど、完全に脱却してしまった。もう一切使っていない。
VScodeへの移行 あれは2016年のことだったか。それとも2017年？　そのころにVScodeに移行したのだと思う。それまではずっとEmacs使いだったけれど、同時にもう何年も、いいかげんやめようと思っていたのだった。正直自分はEmacsを使いこなしていなかったし、Emacsラブということもとくにない。手に馴染むから使っていただけのことだった。それまで、たとえばIntelliJやEclipseを試したこともあったが、重さが気になったり、しっくりこなかった。社内C++業だとなかなかうまく動かないという事情もあるけれど。そういえば一瞬だけちょっとAndroidのことをやったことがあったときはIntelliJを使ったと思う。
さて、そんなわけで「もうEmacsじゃないだろう」とはずっと思っていたけれど、代替物がなかなかないなと思っていたころに、試してみるかと思って使ってみたのが当時流行っていたAtomと、出始めで勢いのあるVScodeだった。で、そのとき試してみたところVScodeのほうがちゃんと動いたのでそっちにするか、と思ってそのまま。VScode / Electronへの理解はまったく深まっていないのだが、なんとなく使えるのでそのまま使っているという、ある種堕落したような使い方をしている。凝った設定はなにもしていない。Emacsからの脱却が目的なのでキーバインド等もいじっていない。
Chromium規模のC++だと標準のモードはけっきょくあまり役に立たないのだが、さいわいChromium内で開発者向けの設定tipsが公開されているので、それをありがたく参照させていただいている。clangdを使った設定がよく動いているのでそれを利用している。OS側でのGo言語利用も、ちょっとだけGOPATH設定などをカスタマイズしているだけで、VScodeで使っている。Goland/CLionはちょっと興味あるけど、使ったことはないなあ。
リモートワークとエディタ環境 さて、2020年になって大部分の時間をリモートワークとして自宅から仕事するようになった。自分の場合、開発用のワークステーションは会社内に置きっぱなしのままで、手元の環境はChromebookだけという状態で仕事をしている。そうすると、sshだけで作業を完結させたくて、コンソール内で動作するテキストエディタに利点が出てきた、ように思える。2020年リモートワークの時代から、コンソールエディタの復権があったりするだろうか？
などと妄想するものの、自分の場合はそうなっていない。実は自分は会社に出勤して仕事してたときから、ずっと手元の操作環境はChromeOSにしていて、開発用ワークステーションへはリモートアクセスしていた。VScodeはリモートデスクトップで接続してそこから使うかたちにしている。リモートデスクトップだとレイテンシが気になるところだと思うのだけど、社内で仕事をしているかぎりはストレスを感じることはほぼなかった。これが自宅からだとどうなるか……と戦々恐々だったが、おもいのほかなんとかなっているので、そのままvscode on remote desktopというスタイルで仕事を続けている。
みんなどうしているんだろうか。自分のごく狭い範囲を観測するかぎり、リモートデスクトップは極端なパターンで、たいていの人はローカルに開発環境を持っていて、そこで開発をしているような気がする。やっぱりコンソールエディタの復権ということはないかな。それに復権するべきコンソールエディタというものの選択肢があまりにもないわけですが。
リモートワーク開発環境どうでしょう。&amp;gt; morrita
 vim ところで今年は Advent of Code を完走してみたのだが、Go言語を使い、コーディングにはおもにvimを使った。手元のChromebookのLinux環境を使っていたので、あんまりヘビーウェイトなもので書きたくない、というわけでvim。gvim使ったりしたけど途中でふつうのvimに移行してしまった。vimのGo言語プラグインはわりとよくできていて不満がない。
ところで、仕事ではだいたいVSCodeだと書いたけど、ちょっとしたことにはやっぱりvimを使っている（なんせgit commitしたらvimでコミットメッセージを書いている）。Emacsからは脱却できたけど、vimを完全に追い出すことはできていない。やっぱりコンソールエディタなのか……というのはふざけているにすぎないが、vimはどこででも動くし役に立つ。でも正直なところ、vimにはいまさらbetしたくないし、凝った設定も入れたくはない。ちょっとしたことを書くのに使うのみにとどめていたい。</description>
    </item>
    
    <item>
      <title>テキストエディタのはなし</title>
      <link>https://messagepassing.github.io/003-editors/01-kzys/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/003-editors/01-kzys/</guid>
      <description>morrita 我々みな Emacs 世代だと思うけど、最近つかってるエディタなんかあります？ (内輪のスレッドより引用)   GoLand 仕事で IntelliJ を使っていたこともあって、仕事の Go は GoLand で書いている。定義元に飛ぶとか、シンボルのリネームとか、IDE っぽい機能が一通り動いて便利。
IDE を使うのは Emacs に無い機能が嬉しいからで、つまり Emacs のキーボードショートカットと IDE のそれは一対一対応にならないので、それなら IDE のキーボードショートカットをちゃんと覚えたほうがいいのでは、と思っているけれど、結局カーソルを動かすとかは Emacs の C-f/n/b/p に慣れすぎていて変えられず、デフォルトのものをちょっとだけ Emacs 風にしている。
Visual Studio Code 自分のブログの Markdown とか、IDE を使わないときは Visual Studio Code を使うことが多い。Visual Studio Code の Emacs 風の拡張はたくさんあるけれど、私は作者の VSCodeのキーバインド拡張を作ったので、その勘所を紹介 に説得 (?) されて、Awesome Emacs Keymap を使っている。
Remote Development が結構よかったのと、edamagit という Magit クローンが気になっていて、この二つをちゃんと自分が使えるようになったら、Emacs 使わなくても良くなるかもしれない。
Emacs でも Emacs もまだ使っている。用途は、Magit:ファイル1枚くらいで完結するスクリプト:複数のプロジェクトを行き来する必要があるとき = 8:1:1 くらいで、昔に比べるとだいぶ減った。
これをここからゼロにするかというと、うーん、どうなんだろう。私は Linux 使いはじめるまえに Meadow (というのは Windows で動く Emacs の一種です) を使っていたりして、Emacs とか Unix っぽいツール群がスッと動くことが Linux 使い出したときの感動のひとつだったりしたので、結構 Emacs 愛があるような気がする。</description>
    </item>
    
    <item>
      <title>Re: Re: Re: 言語のはなし</title>
      <link>https://messagepassing.github.io/002-pl/04-morrita/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/002-pl/04-morrita/</guid>
      <description>F# を日用する karino2, Scala にパッチを書いていた kzys, Haskell の本を書いてしまった jmuk のあとに 日々 for 文を書いて暮らしている自分になにか言うことがあるのか疑問だが、賑やかし程度になんか書く。
Arrow まず冒頭に出てきた F# の bind に相当するのは Kotlin には無いという話。 Kotlin には Arrow という FP 愛好家向けのマイナーライブラリがある。 そして Kotlin には coroutine がある。その二つは一緒に使われて Monad Comprehension という機能になっている。（らしい。）これがどのくらい F# の bind に近いのか自分はよくわからないけれど、そういうのが好きな人はいることはわかる。
一方で、仮にこれがまあまあ monad してるとしても、こうした流儀が Kotlin コミュニティの中心にあるとは思えない。 端的にいうと Android プログラマは(近似的には)誰も仕事で Arrow 使ってないよね。 同じ JVM 言語でも、Scala なら scalaz なり cats なりは もうちょっと受け入れられているように外野からは見える。 (なお森田の Scala FP 力はこの本 を途中で投げ出したくらい。つまり雑魚。あまり真に受けないでいただきたく。) F# は、よくしらないけどたぶんもうちょっと Haskell に近く functional first なのではなかろうか。</description>
    </item>
    
    <item>
      <title>Re: Re: 言語のはなし</title>
      <link>https://messagepassing.github.io/002-pl/03-kzys/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/002-pl/03-kzys/</guid>
      <description>私はむかし Scala が好きだったので、あんまり流行らなかったのは残念です。いや、Scala 3 が Developer Preview に入る年の瀬に過去形で語るのもよくないけれど。
ランタイムが同じ言語を売り込むのは難しい C# と F#, Java と Scala みたいなランタイムが同じ言語は、既存のライブラリなどを使えるという利点はあるけれど、客観的な性能指標とかで明確に「勝つ」ことはなくて、チーム全員を説得するのが大変だと最近は思う。
ファイル一つをコピーすれば動くような実行ファイルを作りたければ Go で、メモリ安全性は手放したくないけれど、ガベージコレクションや大きいランタイムに起因する色々が嫌なら Rust で、みたいな分かりやすさに比べると、F# や Scala の良さって、言語のセマンティクスやシンタックスの話になりがちで、ちょっと弱い。
変数に再代入しない、という当たり前のことを表現するのに final って5文字も書かなくていいんですよ! ていうか Java の Collections.unmodifiableMap() って型に mutable なメソッドが生えてて実行時例外投げるってなんなの? 型に対する冒涜じゃないの? といっても、それがどのくらい許容できるかって人によってだいぶ差があって、我慢できるたぐいの良し悪しと、プログラミング言語に起因するトラブルを抱えるリスクを天秤にかけて、よし今回はこの言語でやってみよう、となることはなかなかない。10年以上プログラマをしているけど、チームの言語を切り替えられた経験って、そういえば一度もないような気がする。
その点でいうと、TypeScript は「型があるんですよ」というのが分かりやすくていい。Kotlin はどうなんだろう。
Scala のキラーアプリは Spark だったのか? Scala に関していうと、Scala が流行り出した頃は、アクターシステムの Akka とか、Rails みたいなフルスタックフレームワークの Lift や Play がキラーアプリになるかと思っていたんだけど、蓋をあけてみると、キラーアプリは Spark だったのかと思う。新しい言語には新しい問題が必要なのかもしれない。
ライブラリってどのくらいあればいいの? あと、ここ10年くらいに出てきた、Node.js (2009-), Go (2009-), Rust (2010-) がそれぞれそれなりの規模のライブラリ群を備えているのをみると、まあ10年くらいはかかっているけど、既存の言語の資産を引き継がなくてもなんとかなるんじゃないか、とも思う。
 karino ランタイムが同じ言語を売り出すのが難しいというのは、まさにC#からF#に乗り換える人はいないというのと同じ話に思う。
F#が面白かったのは、C#から乗り換える人は居なかったのだけどOCamlとかから乗り換える人が居た所だと思うんだよね。 自分もKotlinみたいに使えるコマンドライン言語がほしかったのであって、C#の代替とかCLR上の良い言語を探していた訳じゃない。Golangみたいに使えるKotlinを探していた。 これはF#使っている人が MS MVPとかじゃなくて全然別の、Unix上とかで普段生きている人でGCPやAWS使ってる人になっているところにも現れているんじゃないか。 会社の主流でない事をやっていたら会社には関心の無い他人が寄ってきた、みたいな。</description>
    </item>
    
    <item>
      <title>Re: 言語のはなし</title>
      <link>https://messagepassing.github.io/002-pl/02-jmuk/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/002-pl/02-jmuk/</guid>
      <description>話をふられてなんなんだけど、最近あんまりML系の言語を使ってみたりしていないんだよな。最後になにかやったのは、min-camlがwasmを吐けるようにしたことで、あれはOCamlで書いたのだったか（min-camlはセルフホストではなく、OCamlで書かれている）。公開もしていない……自分で書いた部分がかなりmessyで気が滅入る感じになってしまったので放置している。
Haskellの型クラス そういえばポッドキャストで最近、Haskellの歴史の論文を読んだのを紹介した。2カラムで50ページ以上という長大なる論文なので仕方なくかなりの部分を割愛したが、なかでも型クラスの話はほとんど触れずに飛ばしたように思う。ところがあの論文は &amp;ldquo;being lazy with class&amp;rdquo; という副題がついてるくらい、なにかと型クラスの話をする論文なのだった。論文著者の気持ちとしては、型クラスこそがHaskellの最大の発明であり、特徴であるという気持ちなのかもしれない。
これはポッドキャストでは言及したとおもうが、そもそも型クラスというのは、もともとは数値型と演算子をどうするか、というのが発端だったようだ。プログラミング言語ではたいてい整数型と浮動小数点型があり、+とかみたいな演算子を2引数の関数とみなしたとき、その型が問題になる。たとえば let add x y = x + y のような関数の型はどうあるべきなのか。この解決策として「数値という型クラス」が導入され、型クラスの仕様をみたせばどんな型でもよいことがキレイに表現できる。やったぜ。
しかしこれ、比較的どうでもよい問題について大げさなツールで解決した感は否めない。ほとんどの言語は数値型は特別扱いして、それで大きな問題は起きていない。複数の型を受け入れるためのジェネリクスはよさそうだけど、型クラスというものはなんだか大げさにも思える。
面白いのは、Haskellはこの素朴な型クラスの成功を受けて、それを発展・深化させていったところだった。たとえばモナドができたときも、モナドってつまり型クラスだよね、という話になった。ところが既存の素朴な型クラスの話とモナドは、実はうまくマッチしない。たとえばIntがNumですよ、というのとIOがMonadですよ、というのは話が違う。IOは処理結果を返す型コンストラクタにすぎないから（StringがやってくるIO Stringとか、意味のある値のないIO ()とかが、個別具体的な型になる）。だから、型クラスを拡張して、型コンストラクタも指定できるようにした。さらに、型コンストラクタが複数の型パラメータをもつとき、その型パラメータ間の関係にどんな制約をつけられるだろうか、みたいな方向性にも発展した。
こうやって、型クラスという基礎から始まり、いろいろ複雑な論理関係を表現できるようになった。型クラスというのは出発点の動機は素朴でわりとどうでもいいものだったが、その先にはいろんな発展が見込まれる、豊かな領域の基礎になるものだった（数学者みたいな物言いだけど）。そのことがHaskellまわりの人達を魅了してきたのだろう。
言語のよさと、エコシステムのよさ 話は少しそれるが、あるプログラミング言語のよさみたいなものがあるとして、それってエコシステムに大いに影響されるものだよな、などとこのごろは強く思う。昔はそうでもなかったから、これは自分の年齢が関係するんだろうな。はー歳はとりたくないものだ。でもこれが間違っているというふうにも思いづらい。
エコシステムというのは周辺ツール、ライブラリなどの話であり、言語仕様そのものとは直接的な関係はないといってもいい。どちらかといえば、人がどれだけたくさん寄り付いたかとか、サポートしてくれる企業がどれだけいたか、といった話にもなりがち。でもエコシステムってやっぱり大事なんじゃないか。エコシステムの発達は新しいニーズを生み、それが言語仕様を豊かにしていくという面もある。直接的な関係がないからといって、無関係というわけではない。
Haskellにエコシステムがない……というつもりはない。そんなことを言うと多方面から怒られそう。十分に実用されているとすらいえる。でも他の人気の言語よりはエコシステムはどうしたって薄いだろう。Haskellみたいな言語の型システムは、長年研究者たちを魅了してきたし、それによって豊かに発達したわけだが、でもたとえばtypescriptが急激に発達していろいろわけのわからない型表現を生み出し取り入れているのを眺めるに、エコシステムの発達が生み出す言語仕様の発展ということについても思い馳せるところがないでもない。
F#なんだか面白そうだな、よさそうだな、という感じも、.NETというエコシステムの上によって立つところがあるんじゃないか、というふうに思う。そしてたぶん、その基盤ゆえに独自に発達した言語仕様とかもあるんじゃないかな。そうだとすると面白いな。……と思う一方、いろいろあるJVM系言語については自分は懐疑的な視点を崩せてない（Kotlinはよさそうですけどね）。自分のJava系の経験のうすさゆえだろうか。どうですかね＞和良さんとか？</description>
    </item>
    
    <item>
      <title>Re: Re: バグのはなし</title>
      <link>https://messagepassing.github.io/001-bug/04-karino2/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/001-bug/04-karino2/</guid>
      <description>ここまでのかっこいいバグの話を見て、少し考えてみたが、自分の場合は10年以上前のものが多い。 最近はあんまりそういうバグが無いのだが、なんでかと考えてみる。
 長く使われるコードを書いていない 多くのユーザーに使われるコードを書いていない  という事かなぁ、と思った。
機械学習のバグ 自分のバグでかっこいいのが少ない事の一つに、機械学習の仕事が多かったからというのはあると思う。
例えば機械学習のモデルで変な推論をするみたいな話はまぁあるのだけれど、そういうのが二人のようなかっこいい感じのバグの話にならないのは、 結局そのモデルは早ければ一週間、遅くても開発が続いていれば一ヶ月後には更新されてしまうから。 すぐに更新されちゃうとバグの重みは軽い。というか機械学習のモデルの変な挙動の重みが軽くなるようにみんな体制を作っている。 特にディープなモデルは良く分からん挙動をする事があるからね。
デプロイしたモデルが動いてませんでしたみたいな事はたまにあるし、それは結構な機会損失を生んでたりもするけれど、 revertして直したのを数日後にリリースするだけなのであんまり面白みが無い。
短期のフリーランス的な立ち位置 自分の仕事は短期のフリーランスなので、エンドユーザーになにかデプロイするよりも社内向けのツールとかの仕事が多かったというのもある。 ハードウェアのテストのコードとかは、ハードウェア自身のバグに比べると面白みが無い。 ハードウェアは何億円とか掛けて工場で作って完全に使えない物が出来てしまう事もあるので、結構大ダメージではある。 なのでそういうバグは見てる分には面白かったが、 自分のバグでは無いのであんまりここに書く感じでも無い。
でもフリーランスだから雑用的な仕事が多いのか？というと…どうだろう？そうだとも、そうでないとも言える。 どちらに答えてもやや違和感が残る。
自分の印象としては、働いていた時の他のチームメンバと自分の仕事を比較して、そんなに雑用的な仕事が多かったことも無く、 むしろ短期の手伝いなので重要な仕事をする事の方が多かった。そのチーム内で見た時は正規雇用の社員に比べて雑用をしていた気はしない。
だけれど、そもそも短期のフリーランスを使うチームだという時点で、ある程度の実験的なプロジェクトとかなにかのプロジェクトの立ち上げのところとかが多く、 長く開発が続いているプロジェクトで、バグなどがバグトラッキングシステムで管理されて、それを日々直しつつ開発を続けていく、 みたいな体制のチームでは無い事が多い。 そういう仕事こそが重要な仕事であると思うなら、フリーランスは重要でない仕事が多いといえるかもしれない。
ただ自分はまぁそういうのはもういいかなぁという思いもあるので、フリーランスのお仕事は性にあってる。
会社の主流でない良さ 最近F#が雑用言語としてすごくいいなぁと思っている。 F#がいいと思う事の理由の一つに、Microsoftが力を入れて推し進めているわけ「では無い」ところがある。
C#はMicrosoftの現在の方針を色濃く反映してしまうので、クラウドに力を入れていればクラウドに、 モバイルのクロスプラットフォーム開発に力を入れていればモバイルのクラスプラットフォームに引きづられていろいろと変わっていく。 そうした方針がいつも正しく、よりよい方向に進むとは限らない。特に会社が苦戦している時には。 最近のMicrosoftのモバイル戦略なんかに合わされたらたまったものでは無い（最近の戦略なんて知りもしないで適当な事を言っているが）。
一方F#はそんなに会社の方針に合わせている感じは無く、自由にやらせている雰囲気だ。 VS CodeよりVSを優先しなきゃいけない理由も無くて、中の人も普通にVS Codeの環境をプッシュ出来る。 だからMacで開発する時も普通にVS Codeで快適に開発出来る。 Microsoftが迷走していてもあまり関係無いたたずまいに、ある種の安心感をおぼえる。 でもC#向けにいろいろ入れてくれるクラウド向けのコードなどはありがたく使わせてもらえる。 おいしくタダ乗りさせてもらっている感じが良い。
F#の良さの一つには、こうしたMicrosoftの方針の主流から外れている点があると思う。
外れているせいでC#に比べるとずっと人は掛かっていないと思うが、でも技術的につまらない事をやっている訳では無い。 むしろクロスプラットフォームでML的な関数型言語で大企業にバックアップされた豊富なライブラリというこれまでに無い価値を提供しており、 自分のようにC#よりも価値を見出している人は、Microsoftエコシステムの外にはそれなりに居る気がする。
大本営の方針に従ってやっていく方が価値があるとは限らない。この側面は、ソフトウェア業界にはあるんじゃないかね。 たくさん予算をかけて、凄いたくさんの人で壮大な計画でやった物は失敗する方が多い。 暇な時にちょっと始めた事が大きく広がる事はちょこちょこある。
大多数はどちらも大成功を生み出せないのが結論ではあるので、大本営の方針に従って粛々と働くのがダメって訳じゃない。 でもそういうのから外れた所で小粋にやっていくのもそれなりに意義のある事を生み出せるんじゃないかという気が最近していて、 その辺が「フリーランスの仕事はより雑用的で意義がない」と言う事に違和感を覚える理由にもなっている気がする。
ただフリーランスの仕事には継続的なプレッシャーにさらされる事はあまり無い。 そうした物に耐えてしかなせない事もあるとは思っているので、やっている人たちには敬意を持って接したいとは思うけれど。
という事でF#良いよという話に続く訳だが… 長くなったのでここまででこの話は一旦終えて、F#の話は次回（？）に回す事に。</description>
    </item>
    
    <item>
      <title>言語のはなし</title>
      <link>https://messagepassing.github.io/002-pl/01-karino2/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/002-pl/01-karino2/</guid>
      <description>F#とかML系言語の話 最近どこでもF#いいよしか言ってない気もするけれど、なかなかいいですよ、F#。 Microsoftエコシステムの外の人間の方が使いみちが多いというのが面白いところに思う。 Windows使ってる人じゃなくてMacとかLinux上でコマンドラインでなにかやりたい人にマッチしているのが盲点になりがち。 自分がまさにその盲点にはまってたんですが。
MacとかUnixでも動いて、ファイルのmoveとかcopyとかのシステム周りが一通り揃っていて、 新しい圧縮だとか通信だとかにもちゃんと大企業が対応してくれて（.NETがだけど）、 VSCodeのextentionも良く出来ていて、なおかつML系言語。 Unix系コンソールでのML系言語の時代来たな！
とか思っていたら、和良さんに DarkもOcamlからF#の時代ですよ！ とか教えてもらって、 リンク先を読んでたらReasonML とか Elm を知る。 以前AltJSとしてどっかで見かけた事はあった気がするが、 その時は好きものがやってるだけのマイナープロジェクトくらいに思っていたけれど、 F#もそんな風に思っていたのに使ってみると意外と使える感じだった。 こいつらも結構いいんじゃないか？とか思い始める。
この辺のAltJS系、それなりに流行ってるんですかね？ 自分が知らなかっただけで意外とML系言語の時代来ていた？
F#が普通のプログラマにどのくらい受け入れられるか的な話 流行るといえばどの位一般のプログラマに受けいられるのかが課題。という事で言語的な学習のしやすさを。
F#（というかML）は、表面上はPythonとかとそんなに変わらなくて、見様見真似でもちょっとは書ける。 一方で、いい感じにF#の良さを活かそうとすると、これまでのスタイルとは大きく変えてプログラミングをしないといけない。 例えばF#のパイプ演算子をうまく使うためには関数はカリー化したものを基本としてプログラムしてる方が良くて、 そうするとクラスやオブジェクトでは無くValueを基本にプログラミングをしないといけない。
このプログラムの構成の仕方の変更はそれなりに難しさ、関数型言語の素養を必要とす。 入り口は普通のプログラム言語っぽくても、結局は関数型言語として接する必要はある。 この「関数型言語としてのプログラム構成の仕方を学んで従う」のは、どのくらい普通のプログラマに受け入れられるのか？
あと、F#は割と基本的な所でモナドが出てくる。Option型を扱うのにDSLを作るのが推奨されてるっぽい感じ。 専用の構文があればいいはずなのにそういうのは無くて、 computation expressionというbind系の関数を幾つか実装すると使えるDSLを作る枠組みがあって、それを勧られる。 それにしたって最初からOption用のcomputation expressionで使えるビルダを用意しておいてくれれば、理解しなくてもしばらくは使えると思うのだが、 F#には何故かビルドインではOption用のcomputation expressionのビルダが無いので自分で書かないといけない（6行くらいで書けるけど）。
自分で書くためにはbindってなんだよ、というのを学ぶ必要があり、これはお決まりのモナド入門をやらないといけない。 提供してくれているのを使うだけならもうちょっと後回しに出来るのだけど、 提供してくれてないので言語の入門の割と初期でどうしてもbindの話が出てきてしまう。
教育的配慮もあってそうなってるのかもしれないが、 大多数の人には不要な壁になってしまっている。 F#を使う時の期待値として関数型言語の勉強という側面も持っている気がするので、 初期にbindの必要性に当たるのは悪いとも言い切れないのだけれど。
そもそもbindのシンタックスシュガーってどうなのか？ Bindって今どきのプログラマはどこかでは乗り越え済みなんですかね？
C#はLINQが入った時にみんな頑張ったし、F#も.NET勢なので.NET界隈はなぜかこの辺を普通のプログラマもやる、 という良く分からん風習があった。 でもふと冷静になって外の世界を見渡すと、なんだかんだでモバイルの2大主流言語であるKotlinにもSwiftにもない。 機械学習で主流のPythonにも、Webのフロントエンドで使うJSにもない。
パーサーコンビネータはみんな使ってると思うのだけど、別にbindとか知らんでも使える。
こうして考えると、普通にプログラム言語を使っているとbindのシンタックスシュガーのある言語を触る機会は今でも意外と無さそう。
そもそもF#で初期にbindの例で出てくるOption、先程も言ったとおりちゃんと専用のシンタックスシュガーを導入すればbindのシンタックスシュガーなんて要らないんですよね。 実際KotlinはOption(Nullable)周りに専用のシンタックスシュガーがいろいろ入っていて、 bindのシンタックスシュガーなんて無くてもむしろF#より快適に書ける。
Computation expressionの枠組みでいろいろな物を汎用的に美しく書けるとは言っても、良く出てくるケースはだいたい決まってて、 それ独自のシンタックスシュガーを入れれば特に問題は無い。 Asyncとawaitもcomputation expressionで美しく書けます、と言われても、別にsuspend関数で問題が無い。 専用の構文を入れるのはダサいかもしれないけれど、どうせ似たような仕組みに落ち着くのだから使う側的に違いは無い。 理論的に美しくないだけで学習コストを大きく下げられるのだから、そっちの方が良いのでは？という気もする。
Computation expressionは新たにDSLを作りたい時には強力な仕組みとなる訳だけど、 if elseのショートカットとかをちゃんと実現しようとすれば遅延評価みたいな仕組みも必要になってきて（F#ではDelayというのでこれを行う）、 そんなにシンプルで美しいという訳でも無い。 でもそうしたフルな機能が要らないなら別にKotlinのようにインライン周りの工夫が入っているだけで十分だったりする。 むしろreturn周りなんかはKotlinの方がシンプルに書ける事も多い。</description>
    </item>
    
    <item>
      <title>Re: Re: バグのはなし</title>
      <link>https://messagepassing.github.io/001-bug/03-jmuk/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/001-bug/03-jmuk/</guid>
      <description>あんまりかっこいいバグというわけでもないが、解決が楽しかったのでここに書いて供養しておこう。
最近はOSの性能テストをよく書いて計測している。Go言語で書いたテストコードがコンパイルされた上で実機上で動いてOSをいろいろ操作させるというものだが、こういうend-to-endなテストの性質上、壊れることもよくある。ある日のテストの失敗レポートもそういうよくあるやつに見えた。
ログを見ると、なかなか失敗しなさそうなところでタイムアウトして失敗している。理由もよくわからない。手元で再現させてみるが、もちろん再現しない。ところがCIでは頻繁に失敗している。なぜだろう？　考えられるのは、同じ試行で走っている前のテストケースの影響だ。それで思いつく関係しそうなテストケースをいろいろ組み合わせてみるが、それでも再現しない。
もうちょっと良く見てみよう、と失敗したログを見てみる。失敗した場合、psのダンプも保存してくれるので、それも見てみる。すると……実機上のテストコード自体のCPU負荷が300%を越えてる！！　これなのは間違いない。テストコードが狂っていてCPU負荷が高くなりすぎてOSがまともに動作できず、普段なら失敗しないところでもタイムアウトしてしまうというわけだ。
しかし何が原因なのか、どこにCPUを使っているのかは謎のままだった。仕方ないので、同じ試行で走るべき全テストを実行させつつtopでCPU使用率を目で追ってみた。するとテストの早い段階でとあるテストケースが失敗すると、その後のCPU使用率が100%を越えることがわかった。これだろう。CPU利用率は違うが、同じ問題を引き起こすテストケースがほかにいくつかあるのだろう。
問題の分析 再現環境が手に入ったので話はずいぶん簡単になったが、まだ何故これが起きたのかはわかっていない。Go言語にはプロファイラが標準で入っているから、これを使ってみることにする。自分のテストのほうでプロファイラを取るようにし、問題を起こすテストケースと自分のテストケースの2つだけを実行させる。で、これをflame graphで眺めてみたら問題は一目瞭然。cdpというライブラリのなかの、とあるgoroutineが大幅にCPUサイクルを消費している。しかもその消費の大部分は文字列フォーマットとエラーオブジェクトの構築。ようするに、エラーの報告しまくっているということだ。
cdpというのはChrome devtools protocolの略だ。OSやブラウザをテストから操作するためにこのプロトコルを使っていて、cdpというのはこれをGoから使えるようにしているサードパーティのライブラリだったが、どうもここにバグがあるらしい。それで調べてみると、たしかに問題の起きたOSバージョンから、cdpのバージョンを上げる変更が入っている。手元でcdpのバージョンを落としてみると問題が直る。
というわけでcdpのバージョンを戻せば解決するが、それじゃ本質的な解決にはならないので、もうすこしcdpの中身を眺めてみる。すると、このgoroutineは実際にchromeとのメッセージをやりとりするようなものだった。何らかの理由で通信チャネルが閉じたらエラーになるが、エラーといってもいろいろなので「エラーが起きたらエラーオブジェクトを作って報告する。もしそれがcloseに関係するエラーだったらgoroutineを終了する」といったロジックになっていた。どうも、問題の事例では本当は通信チャネルが閉じたのに、closeエラーかどうかの判定が間違っていたためgoroutineが止まらず、ビジーループでエラーオブジェクトを作り続ける無限ループに陥っていたようだ。
実際に起きているエラーがなんなのか見る方法はないだろうか？　テストは実機で走っているので、ログは簡単には仕込めない。テストインフラ側には専用のロガーがあるが、依存先であるサードパーティライブラリはそのロガーのことを知らない……。ただcdpはエラーをGoのchannelに書き出してくれていたので、テストシナリオの側でこのchannelを読んでテストインフラのロガーに流すコードを仕込んでみた。すると、たしかにエラーオブジェクトが無数に流れてくる。根本的には、cdpライブラリがさらに依存しているwebsocketライブラリのcloseエラーになっているが、手前がcdpのcloseエラーになっていないので、判定に失敗しているようだ。
解決 いったん手元では雑なパッチで修正し、問題としてはひとまず解決した。これをupstreamすることにしたのだが、そこでもうすこし問題の詳細を眺めてみた。
さっきも書いたように、いちばん根底のエラーはwebsocketライブラリのエラーだった。一番手前のエラーは全然別のエラーだ。Go言語では、こういうふうにエラーオブジェクトをベースにしてちょっとエラーメッセージを追記するようなwrapがよく行われている。cdpライブラリの場合、Causeという独自のメソッドがあり、wrappingを剥がして元のエラーオブジェクトを取れるようになっている。
ライブラリとしての構造が複雑になってくると、こういうwrappingは多段化しがちだ。実際このケースでもそうで、複数段のwrappingが入っていた。ところが問題の無限ループでは、一番手前のエラーオブジェクトと、一番奥のエラーオブジェクト（websocketライブラリのエラーオブジェクト）しかチェックしていない。実際にはcdpライブラリのcloseエラーは正しく存在していたが、この多段wrappingの中間にしかなかったので、無視される状態になっていた。そこで、このwrappingを一段ずつはがしてチェックするように修正をつくってupstreamした。これがマージされたのでこの問題はおしまい。
ところで、ちょっと勘のいいGoプログラマは気づいたかもしれないが、これはGo 1.13で導入されたerrors.Isと類似性がある( https://blog.golang.org/go1.13-errors )。Go 1.13ではerrors.Isという関数ができて、こういう「ほかのエラーオブジェクトをラップしたエラーオブジェクトとの一致チェック」というパターンを簡単にかけるようになった。errors.Isでは、エラーオブジェクトにUnwrapというメソッドがないかチェックする。あるならそれを使ってwrapを外す。どこかでtargetと一致するエラーがあったらtrueを返す。どこにもなくunwrapできなくなったらfalse。
ただ、cdpライブラリの状況ではこれはそのまま使えるものではない（とくに==でのチェックだと厳しい）。使えるようにするにしてもかなりの再設計が必要になるだろう。でもまあよくあるパターンとして比較的最近、標準でサポートされるような問題ではあるという話だったのは興味深かった。
 最後は karino2.</description>
    </item>
    
    <item>
      <title>Re: バグのはなし</title>
      <link>https://messagepassing.github.io/001-bug/02-kzys/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/001-bug/02-kzys/</guid>
      <description>他人にバグ修正を頼むのはよくないという反省から、このあと森田は OS ツリーのビルド、インストール方法を調べ 手元で OS のコードをいじれるようにしたのだった。ただしその成果を発揮する日は今の所きていない。来なくていいです
サーバサイドのかっこいいバグの話なんかないですか &amp;gt; 和良
 よくないまでいうと語弊があるけれど、自分で直したほうが楽ですよね。そうして軽い気持ちで手を出すと大事になったりするんですが&amp;hellip;。
というわけで、1行変更するだけのつもりが大事になった話をひとつ。
seccomp Firecracker では Linux の seccomp という仕組みを使って、Firecracker プロセスが呼び出せるシステムコールについて許可リストをもっている。Firecracker のなかで動くゲストの Linux は様々なシステムコールを自由に発行できるけれど、Firecracker プロセスがホストの Linux に対して呼び出すシステムコールは厳選されている。
実際の許可リストは、src/vmm/src/default_syscalls/filters.rs にある。この仕組みは、本来なら libc やライブラリが隠蔽してくるはずの実装の詳細であるシステムコールを細かく列挙しなくてはいけないので、結構きびしい。
このとき直したかったバグでは
 After more digging, looks like the rt_sigprocmask is unescapable. It&amp;rsquo;s also called from __block_all_sigs, which is in turn called by pthread_exit. Basically musl took every precaution and blocks signals whenever something signal-unsafe is underway.
 Firecracker がスレッドを終了すると、musl libc 経由で pthread_exit が呼ばれて、そこから rt_sigprocmask というシステムコールが呼ばれてしまうので、結果として seccomp 違反で Firecracker が殺されてしまう、という話だった。</description>
    </item>
    
    <item>
      <title>バグのはなし</title>
      <link>https://messagepassing.github.io/001-bug/01-morrita/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/001-bug/01-morrita/</guid>
      <description>なにか話すことはないかと Hacker News をみていたら（ろくでもない）、 Youtube や Gmail など Google のサービスが一時間落ちていたというニュースで 盛り上がっていた。担当者の想像するだけで胃が痛い。
森田はクライアントサイドで仕事をしているので、この手の outage は起きない。 けれど自分のところに担当したくないイヤなバグが回ってくることはたまにある。 そういうのを精神衛生を害さない程度で思い出してみたい。
A Ship Blocker 何年か前にカメラアプリのチームに入った直後、ハカソンでカメラのビューファインダに OpenGL のシェーダで簡単なエフェクトをかけるコードを書いた。
ハカソン最終日のデモで成果を紹介すると、より洗練されたリアルタイムエフェクトを近隣のアルゴリズムチームが長いこと構想していたことがわかった。 そこで彼らが開発していたエフェクトのフレームワークを森田がカメラアプリにインテグレートすることになった。 とはいえアルゴリズムの開発は始まったばかりで出荷するのはまだ先になりそうな雰囲気。 アルゴリズムチームがアプリ内で試行錯誤できるよう、早速ハカソンのコードをベースに最低限のインテグレーションを済ませた。
その仕事のことをすっかり忘れていたある日、アルゴリズムチームの人が「そろそろ出荷に向けて準備したいのでバグなおしてくれない？」とやってきた。 改めて自分のインテグレーションを見直すと・・・バグだらけじゃん。特に電話機の向きを縦から横にかえた時に描画が壊れる。 やれやれ・・・と直そうとするも、API が期待通りに動かない。
一週間以上たってもなぜ動かないのかわからないので途方にくれ、 小さな再現ケースをつくって、 正しくうごくケースすなわちエフェクトなしのコードパスと挙動を比べてみると・・・。
これ OS のバグじゃね？という結論に至った。 一般に OS のバグを疑うときは自分が間違っているものだが、Android に限るとその限りでない。 先に書いた再現ケースを片手にバグ報告をする。
が、まったく相手にされる様子がない。 しびれを切らしたアルゴリズムチームのプログラマがやってきた。「担当者に直談判しましょう」という。 仕方ないので質問ドキュメントを事前に送付の上ミーティング。「ああわかったきがする。すぐ直すよ」と担当者。
しかしコードがチェックインされたのはそこから一ヶ月後だった。しかも直ってない！どうなってんた！ アルゴリズムチームにつつかれ、ふたたびミーティング。前回は問題だけ伝えたのがよくなかっという反省から、 もう少し要求を細かく伝える。このあとようやく修正が通り、デモが動くようになった。
しかし OS のバグはトランクでのみ修正されており、気がつくとリリースブランチはとっくの昔に切られていた。 そして cherry-pick の締切も過ぎていた。この OS のバグにブロックされ、リアルタイムエフェクトの出荷は一年先送りとなった。
二年目 一年後に向けてアルゴリズムチームはエフェクト実装の改善を進めていた。 具体的には消費電力の改善に取り組んでいた。（つまり OS のバグがあろうがなかろうが出荷できなかったのだね・・・。） 試行錯誤の過程で、彼らはアプリとのインテグレーションも大きくデザインを変えていた。つまり森田がハカソンで書いたコードは姿を消していた。
その仕事のことをすっかり忘れていたある日、アルゴリズム班の人がやってきて「エフェクトが動かないのでなんとかしてほしい」という。 久しぶりに見ると見慣れないコードばかり。インテグレーションに使う OS の API も SurfaceView から ImageReader へ、ずいぶん変わっている。 そしてこれが動かないのは・・・ OS のバグなのでは？ 嫌な既視感に襲われつつバグを報告するも、やはり直らないバグ。またしびれを切らして直談判。</description>
    </item>
    
  </channel>
</rss>
